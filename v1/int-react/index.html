

<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><title>React — Kingly.js</title>
  <meta charset="utf-8">
  <meta name="description" content="Kingly - The Modelling Library for Portable UIs">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

  <meta property="og:type" content="article">
  <meta property="og:title" content="React — Kingly.js">
  <meta property="og:description" content="Kingly - The Modelling Library for Portable UIs">
  <meta property="og:image" content="https://brucou.github.io/documentation//documentation/images/kingly_logo.png">
  <!-- Twitter -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="React — Kingly.js">
  <meta name="twitter:description" content="Kingly - The Modelling Library for Portable UIs">
  <meta name="twitter:image" content="https://brucou.github.io/documentation/images/kingly_logo.png">

  <link rel="apple-touch-icon" sizes="180x180" href="/documentation/images/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/documentation/images/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="256x256" href="/documentation/images/icons/favicon-256x256.png">
  <link rel="icon" href="/documentation/images/kingly_logo.png" type="image/png">

  <link href="//fonts.googleapis.com/css?family=Lato:300,400,600" rel="stylesheet" type="text/css">
  <link href="//fonts.googleapis.com/css?family=Overlock:400&text=Kingly.js" rel="stylesheet" type="text/css">

  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

  <!-- main page styles -->
  <link rel="stylesheet" href="/documentation/css/page.css">

  <!--<script src="/documentation/js/kingly.js"></script>-->

  <!-- ga -->
  <script>
    (function (i, s, o, g, r, a, m) {
      i['GoogleAnalyticsObject'] = r;
      i[r] = i[r] || function () {
        (i[r].q = i[r].q || []).push(arguments)
      }, i[r].l = 1 * new Date();
      a = s.createElement(o),
        m = s.getElementsByTagName(o)[0];
      a.async = 1;
      a.src = g;
      m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

    ga('create', 'UA-141924019-1', 'brucou.github.io/documentation');
    ga('send', 'pageview');
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  </head>

  <body class="docs">    <div id="mobile-bar">
      <!-- hexo-inject:begin --><!-- hexo-inject:end --><a class="menu-button"></a>
      <a class="logo" href="/documentation"></a>
    </div>
    

<div id="header">
  <a id="logo" href="/documentation/">
    <img src="/documentation/images/kingly_logo.png" alt="library logo">
    <span>Kingly</span>
    
  </a>
  <ul id="nav">
    <li class="nav-dropdown-container learn">
  <a class="nav-link">Learn</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li>
      <ul>
        <li><a href="/documentation/v1/tutorials/" class="nav-link">Tutorials</a></li>
        <li><a href="/documentation/v1/examples/" class="nav-link">Examples</a></li>
        <li><a href="/documentation/v1/cookbook/" class="nav-link">Cookbook</a></li>
        <li><a href="/documentation/v1/best-practices/" class="nav-link">Best practices</a></li>
      </ul>
    </li>
  </ul>
</li>

<li>
  <a href="/documentation/v1/api/index.html" class="nav-link team">API</a>
</li>
<li class="nav-dropdown-container tooling">
  <a class="nav-link">Tooling</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li>
      <ul>
        <li><a href="/documentation/v1/tooling/tools_overview.html" class="nav-link">Overview</a></li>
        <li><a href="/documentation/v1/tooling/graph_editing.html" class="nav-link">Graph editing</a></li>
        <li><a href="/documentation/v1/tooling/compiling.html" class="nav-link">Compiling</a></li>
        <li><a href="/documentation/v1/tooling/devtool.html" class="nav-link">Devtool</a></li>
      </ul>
    </li>
  </ul>
</li>

<li class="nav-dropdown-container integrations">
  <a class="nav-link current">Integrations</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li>
      <ul>
        <li><a href="/documentation/v1/int-vanilla/" class="nav-link">Vanilla js</a></li>
        <li><a href="/documentation/v1/int-react/" class="nav-link">React</a></li>
        <li><a href="/documentation/v1/int-vue/" class="nav-link">Vue</a></li>
        <li><a href="/documentation/v1/int-svelte/" class="nav-link">Svelte</a></li>
        <li><a href="/documentation/v1/int-others/" class="nav-link">Others</a></li>
      </ul>
    </li>
  </ul>
</li>

<li>
  <a href="/documentation/v1/testing/index.html" class="nav-link team">Testing</a>
</li>
<li>
  <a href="/documentation/v1/contributed/index.html" class="nav-link team">Contributed</a>
</li>

  </ul>
</div>

    
      <div id="main" class="fix-sidebar">
          
  <div class="sidebar">
  <div class="sidebar-inner">
    <ul class="main-menu">
      <li class="nav-dropdown-container learn">
  <a class="nav-link">Learn</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li>
      <ul>
        <li><a href="/documentation/v1/tutorials/" class="nav-link">Tutorials</a></li>
        <li><a href="/documentation/v1/examples/" class="nav-link">Examples</a></li>
        <li><a href="/documentation/v1/cookbook/" class="nav-link">Cookbook</a></li>
        <li><a href="/documentation/v1/best-practices/" class="nav-link">Best practices</a></li>
      </ul>
    </li>
  </ul>
</li>

<li>
  <a href="/documentation/v1/api/index.html" class="nav-link team">API</a>
</li>
<li class="nav-dropdown-container tooling">
  <a class="nav-link">Tooling</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li>
      <ul>
        <li><a href="/documentation/v1/tooling/tools_overview.html" class="nav-link">Overview</a></li>
        <li><a href="/documentation/v1/tooling/graph_editing.html" class="nav-link">Graph editing</a></li>
        <li><a href="/documentation/v1/tooling/compiling.html" class="nav-link">Compiling</a></li>
        <li><a href="/documentation/v1/tooling/devtool.html" class="nav-link">Devtool</a></li>
      </ul>
    </li>
  </ul>
</li>

<li class="nav-dropdown-container integrations">
  <a class="nav-link current">Integrations</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li>
      <ul>
        <li><a href="/documentation/v1/int-vanilla/" class="nav-link">Vanilla js</a></li>
        <li><a href="/documentation/v1/int-react/" class="nav-link">React</a></li>
        <li><a href="/documentation/v1/int-vue/" class="nav-link">Vue</a></li>
        <li><a href="/documentation/v1/int-svelte/" class="nav-link">Svelte</a></li>
        <li><a href="/documentation/v1/int-others/" class="nav-link">Others</a></li>
      </ul>
    </li>
  </ul>
</li>

<li>
  <a href="/documentation/v1/testing/index.html" class="nav-link team">Testing</a>
</li>
<li>
  <a href="/documentation/v1/contributed/index.html" class="nav-link team">Contributed</a>
</li>

    </ul>
    <div class="list">
      
        <h2>
          
          Integrations
          
        </h2>
        <ul class="menu-root">
  
    
    
    
    <li>
      <a href="/documentation/v1/int-vanilla/index.html" class="sidebar-link">Vanilla JavaScript</a>
    </li>
  
    
    
    
    <li>
      <a href="/documentation/v1/int-react/index.html" class="sidebar-link current new">React</a>
    </li>
  
    
    
    
    <li>
      <a href="/documentation/v1/int-vue/index.html" class="sidebar-link">Vue</a>
    </li>
  
    
    
    
    <li>
      <a href="/documentation/v1/int-svelte/index.html" class="sidebar-link">Svelte</a>
    </li>
  
    
    
    
    <li>
      <a href="/documentation/v1/int-cycle/index.html" class="sidebar-link">Cycle.js</a>
    </li>
  
    
    
    
    <li>
      <a href="/documentation/v1/int-others/index.html" class="sidebar-link">Other frameworks</a>
    </li>
  
</ul>

      
    </div>
  </div>
</div>



<div class="content integrations with-sidebar ">
  
    
    
  
  
    <h1>React</h1>
  
  
    <p>We provide an integration of Kingly with React with the <a href="https://github.com/brucou/react-state-driven" target="_blank" rel="noopener"><code>react-state-driven</code></a> library. </p>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>User interfaces are reactive systems which can be modelized accurately by state machines. There is a number of state machine libraries in the field with varying design objectives. We have proposed a state machine library with a minimal API, consisting of a single effect-less function. </p>
<p> In this particular design, the machine is a function which takes inputs (events to be processed  by the machine) and outputs commands to be executed. While it is entirely possible to modelize  an entire web application with state machines, a common use case is to modelize a component, and reuse that component. </p>
<p> This library proposes an integration of the Kingly state machine library with React that takes  the shape of a <code>&lt;Machine /&gt;</code> component which can be used in a React application like any other components. The <code>&lt;Machine /&gt;</code> component will listen to user events, compute commands and execute  them, generally leading to updating the screen.</p>
<h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><p><code>react</code>  is a peer dependency. The component has been tested with React 16.4 and above. It may however work with lower versions of React as it does not use hooks, context, etc. If you encounter an issue with a given version of React, please log an issue.</p>
<pre><code class="hljs sh">npm install react-state-driven</code></pre>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="lt-Machine-fsm-renderWith-commandHandlers-eventHandler-preprocessor-effectHandlers-options-gt"><a href="#lt-Machine-fsm-renderWith-commandHandlers-eventHandler-preprocessor-effectHandlers-options-gt" class="headerlink" title="&lt;Machine fsm, renderWith, commandHandlers, eventHandler?, preprocessor?, effectHandlers?, options? /&gt;"></a><code>&lt;Machine fsm, renderWith, commandHandlers, eventHandler?, preprocessor?, effectHandlers?, options? /&gt;</code></h3><p>We expose a <code>&lt;Machine /&gt;</code> React component which will hold the state machine and implement its behaviour using React’s API. The <code>Machine</code> component behaviour is specified by its props. </p>
<p>There are 3 mandatory props and four optional props. The three mandatory props are the machine specifying the component’s behavior, the component to render the screens with, and the command handlers to execute the commands computed by the machine.</p>
<p>The four optional props exist to address more complex use cases without modifying the <code>&lt;Machine/&gt;</code> component. This is in line with the open-closed principle which states that “software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification”. </p>
<p>We will examine these use cases in a dedicated section. Let’s now describe the semantics of the component:</p>
<ul>
<li>When the React <code>Machine</code> component is mounted, the <code>fsm</code> machine will be sent an event (called <code>MOUNTED</code> by default, and configurable in <code>options.initialEvent</code>). From that event, the machine generally computes the initial screen to be rendered. In fact, the machine computes a <code>RENDER</code> command, which includes the props for the <code>renderWith</code> component whose single responsibility is to render the screens for the <code>Machine</code> component.<ul>
<li>Assuming <code>fsm({[MOUNTED]: void 0}) = [{command: RENDER, params: initialProps}]</code>, and   <code>renderWith = Component</code> the screen <code>&lt;Component next {...initialProps} /&gt;</code> will be displayed when   the <code>Machine</code> component is mounted</li>
</ul>
</li>
<li>The <code>&lt;Component /&gt;</code> rendering screens is injected by <code>&lt;Machine /&gt;</code> with a <code>next</code> prop, which is an event dispatcher whose end is connected to the <code>fsm</code> machine. That means that <code>next(event)</code>  will trigger the computation of <code>fsm(event)</code>. The <code>next</code> prop is thus used by the <code>Component</code> to  pass events that to the machine. Typically, as <code>Component</code> only handles rendering, the   aforementioned events are DOM or user events.</li>
<li>The <code>fsm</code> machine computes commands in response to received events. The <code>commandHandlers</code> prop assigns handlers for every possible command generated by the machine. Computed commands are executed with the dedicated handler. Handlers are passed the <code>next</code> dispatcher as it is often necessary to pass back to the machine the results of an executed command. For instance, if a command fetches remote data, that remote data may be fed back to the machine in the shape of a <code>SUCCESS</code> event. Conversely, an <code>ERROR</code> event may be sent back to indicate that the fetching has failed.  </li>
</ul>
<p>The previous paragraph describes how the mandatory props (<code>fsm</code>, <code>renderWith</code>, <code>commandHandlers</code>) are used. Let’s talk about the optional props:</p>
<ul>
<li><code>eventHandler</code> defaults to a minimal event emitter based on <a href="https://github.com/konsumer/emitonoff" target="_blank" rel="noopener"><code>emitonoff</code></a>, a 300B library. You can provide your own event emitter fitting your own purposes. The event handler is an object with a <code>next</code> method. If no preprocessor is used, then the event handler should also have a <code>subscribe</code> method which when called returns an object with an <code>unsubscribe</code> method. This means that using a Subject as event handler is as easy as <code>eventHandler = new Rx.Subject()</code>. The event handler may also have <code>error</code> and <code>complete</code> methods if the API user wants to deal with errors and disposal of resources in some ad-hoc ways.<ul>
<li>the <code>preprocessor</code> is receiving all events sent by the <code>next</code> dispatcher and converting them into events for the <code>fsm</code> machine. The preprocessor defaults to <code>x =&gt; x</code> i.e. the identity function. </li>
<li><code>effectHandlers</code> allows command handlers to be more single-concern. Executing a command may involve realizing and coordinating several effects. In a clean architecture, the command handlers should only orchestrate the sequence of effects realizing the commands, and  the effects should only, well, execute a single effect. This is useful for testing purposes, as orchestration can be tested separately from effect execution. </li>
<li><code>options</code> is designed to be a bag that gathers all customization opportunities which do not belong to any of the other classifications. As of now, it includes an <code>initialEvent</code> property which configured the event that will be run through the machine when mounting the <code>&lt;Machine /&gt;</code> component </li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Option</th>
<th>Use case</th>
</tr>
</thead>
<tbody>
<tr>
<td>eventHandler</td>
<td>- pass events from outside the component or from outside the DOM, for instance to communicate with other components</td>
</tr>
<tr>
<td>preprocessor</td>
<td>- convert one DOM event into one semantic event. For instance, convert a button click (no semantics) into a search intent or submit intent (note the semantics).</td>
</tr>
<tr>
<td></td>
<td>- aggregate several DOM events into one event. For instance, throttle button clicks</td>
</tr>
<tr>
<td></td>
<td>- pass events from outside the component or from outside the DOM, for instance to communicate with other components</td>
</tr>
<tr>
<td>effectHandlers</td>
<td>- large component, or complex behavior where clean code matters</td>
</tr>
<tr>
<td></td>
<td>- customizing render handler (default is React.setState), for instance running some operations before or after rendering</td>
</tr>
<tr>
<td>options</td>
<td>- configure initial event. This also entirely decouples the <code>fsm</code> machine from the <code>Machine</code> component</td>
</tr>
</tbody>
</table>
</div>
<p>Note that our <code>Machine</code> component expects some props but does not expect children components. </p>
<p>We provide two examples, one illustrating the mandatory props, the second illustrating all optional props.</p>
<h3 id="Example-with-mandatory-props"><a href="#Example-with-mandatory-props" class="headerlink" title="Example with mandatory props"></a>Example with mandatory props</h3><p>This example only uses the mandatory props. It also uses JSX, and <a href="http://jsonpatch.com/" target="_blank" rel="noopener">JSON Patch</a> to update the machine’s extended state. We use JSON Patch mainly to provide an example of configuration of <code>updateState</code> property. You may use a simple <code>Object.assign</code>-based reducer, or <a href="https://github.com/immerjs/immer" target="_blank" rel="noopener">Immer</a> or any other reducing function.</p>
<p>For illustration, the behavior modelization is as follows:</p>
<p><img src="https://res.infoq.com/articles/robust-user-interfaces-with-state-machines/en/resources/18-movie-search-good-fsm-corrected-flowchart%20no%20emphasis%20switchMap-1555879148127.jpg" alt="image search interface"> </p>
<p>The demo application can be evaluated in a <a href="https://codesandbox.io/s/react-movie-app-state-driven-with-default-options-18m62?file=/src/MovieSearch.js" target="_blank" rel="noopener">codesandbox playground</a>.</p>
<h3 id="Example-with-optional-props"><a href="#Example-with-optional-props" class="headerlink" title="Example with optional props"></a>Example with optional props</h3><p>This example uses the optional props. It uses hyperscripts instead of JSX and an Rxjs Subject for event emitter, and JSON patch to update the machine’s extended state.</p>
<p>We will implement an <a href="https://css-tricks.com/robust-react-user-interfaces-with-finite-state-machines/#article-header-id-5" target="_blank" rel="noopener">image search application</a>.<br>That application basically takes an input from the user, looks up images related to that search input, and displays them. The user can then click on a particular image to see it  in more detail. </p>
<p>For illustration, the user interface starts like this:</p>
<p><img src="https://i.imgur.com/mDQQTX8.png?1" alt="image search interface"> </p>
<p><a href="https://codesandbox.io/s/flickr-search-app-with-kingly-qivl3" target="_blank" rel="noopener">Click here</a> for a live demo.</p>
<p>The user interface behaviour can be modelized by the following machine:</p>
<p><img src="assets/image%20gallery%20state%20cat.png" alt="machine visualization"></p>
<p>The visual notation for the modelization is addressed in Kingly documentation. We recall here the main points: </p>
<ul>
<li>the black bullet (entry point) from our machine graph corresponds to a <code>init</code> control state, which moves to the <code>start</code> control state with the initial event <code>START</code>.</li>
<li><code>events</code> and <code>states</code> respectively are a list of events and control states accepted and represented in the machine</li>
<li><code>initialControlState</code> and <code>initialExtendedState</code> encode the initial state for the machine</li>
<li>the <code>transitions</code> property of the machine encodes the edges of the graph that modelizes the behaviour of the interface</li>
<li><code>updateState</code> specifies how to update the extended state of the machine from a description of the updates to perform. We use <a href="http://jsonpatch.com/" target="_blank" rel="noopener">JSON patch</a> in our example. A redux-like reducer, proxy-based <code>immer.js</code> or any user-provided function could also be used, as long as it respects the defined interface.</li>
</ul>
<h4 id="Using-a-preprocessor"><a href="#Using-a-preprocessor" class="headerlink" title="Using a preprocessor"></a>Using a preprocessor</h4><p>In this example, we translate DOM events into machine events with a preprocessor. The preprocessor is a function that receives the event handler as parameter (named <code>rawEventSource</code> here). As the event handler chosen is a Rx.js Subject, we can use <code>pipe</code>, <code>map</code> and all the Rx.js combinators to perform our event conversion. This example for instance eliminates all unnecessary information from the DOM events and React framework (<code>ref</code>), so the machine events are completely decoupled from the DOM. </p>
<p>We thus move from <code>onSubmit</code>,<code>onCancelClick</code>, <code>onGalleryClick</code>, <code>onPhotoClick</code> DOM events to <code>SEARCH</code>, <code>CANCEL_SEARCH</code>, <code>SELECT_PHOTO</code>, <code>EXIT_PHOTO</code> machine events.</p>
<p>The preprocessor must return an object with a <code>subscribe</code> property by which the values computed in the preprocessor will flow. In other words, the preprocessor must return an observable. The <code>subscribe</code> method must return an object with an <code>unsubscribe</code> method which will be called when the <code>&lt;Machine /&gt;</code> component is unmounted. The API is thus designed to be a perfect fit for Rxjs Subjects and Observables.</p>
<pre><code class="hljs js">...
preprocessor: <span class="hljs-function"><span class="hljs-params">rawEventSource</span> =&gt;</span>
  rawEventSource.pipe(
    map(<span class="hljs-function"><span class="hljs-params">ev</span> =&gt;</span> &#123;
      <span class="hljs-keyword">const</span> &#123; rawEventName, <span class="hljs-attr">rawEventData</span>: e, ref &#125; = destructureEvent(ev);

      <span class="hljs-keyword">if</span> (rawEventName === INIT_EVENT) &#123;
        <span class="hljs-keyword">return</span> &#123; [INIT_EVENT]: <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> &#125;;
      &#125;
      <span class="hljs-comment">// Form raw events</span>
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rawEventName === <span class="hljs-string">"START"</span>) &#123;
        <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">START</span>: <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> &#125;;
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rawEventName === <span class="hljs-string">"onSubmit"</span>) &#123;
        e.preventDefault();
        <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">SEARCH</span>: ref.current.value &#125;;
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rawEventName === <span class="hljs-string">"onCancelClick"</span>) &#123;
        <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">CANCEL_SEARCH</span>: <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> &#125;;
      &#125;
      <span class="hljs-comment">// Gallery</span>
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rawEventName === <span class="hljs-string">"onGalleryClick"</span>) &#123;
        <span class="hljs-keyword">const</span> item = e;
        <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">SELECT_PHOTO</span>: item &#125;;
      &#125;
      <span class="hljs-comment">// Photo detail</span>
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rawEventName === <span class="hljs-string">"onPhotoClick"</span>) &#123;
        <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">EXIT_PHOTO</span>: <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> &#125;;
      &#125;
      <span class="hljs-comment">// System events</span>
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rawEventName === <span class="hljs-string">"SEARCH_SUCCESS"</span>) &#123;
        <span class="hljs-keyword">const</span> items = e;
        <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">SEARCH_SUCCESS</span>: items &#125;;
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rawEventName === <span class="hljs-string">"SEARCH_FAILURE"</span>) &#123;
        <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">SEARCH_FAILURE</span>: <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> &#125;;
      &#125;

      <span class="hljs-keyword">return</span> NO_INTENT;
    &#125;),
    filter(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x !== NO_INTENT),
  ),</code></pre>
<h4 id="Using-effect-handlers"><a href="#Using-effect-handlers" class="headerlink" title="Using effect handlers"></a>Using effect handlers</h4><p>In this example, we use two effect handlers, one to perform an API call, and the other one to perform rendering. We discuss the rendering in the next section. Effect handlers can only be called by command handlers, as command handlers are the only functions that receive the effect handlers as parameters. Here, our API call is a <code>fetchJsonp</code>: </p>
<pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">runSearchQuery</span>(<span class="hljs-params">query</span>) </span>&#123;
  <span class="hljs-keyword">const</span> encodedQuery = <span class="hljs-built_in">encodeURIComponent</span>(query);

  <span class="hljs-keyword">return</span> fetchJsonp(
    <span class="hljs-string">`https://api.flickr.com/services/feeds/photos_public.gne?lang=en-us&amp;format=json&amp;tags=<span class="hljs-subst">$&#123;encodedQuery&#125;</span>`</span>,
    &#123; <span class="hljs-attr">jsonpCallback</span>: <span class="hljs-string">"jsoncallback"</span> &#125;
  ).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.json());
&#125;
...
  effectHandlers: &#123;
    <span class="hljs-attr">runSearchQuery</span>: runSearchQuery,
    ...
  &#125;
...</code></pre>
<p>Using effect handlers may seem overkill in some simple applications. In most cases, the only orchestration necessary is handling failing and successful effect execution with two different events. This is why effect handlers are optional. In more complex cases, however, where the orchestration is complex, it will be useful to separate the orchestration of effects from the execution of effects. This is a tenet of functional programming: separating concerns enables easier testing, better composition, and reuse.</p>
<h4 id="Customizing-rendering"><a href="#Customizing-rendering" class="headerlink" title="Customizing rendering"></a>Customizing rendering</h4><p>To customize rendering, we can override the default render handler. Rendering, as a matter of fact, is handled by an effect handler as any other effects. The effect handler for rendering can be configured on the key <code>[COMMAND_RENDER]</code>:</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> flipping = <span class="hljs-keyword">new</span> Flipping();
...
  effectHandlers: &#123;
  ...
    [COMMAND_RENDER]: <span class="hljs-function">(<span class="hljs-params">machineComponent, renderWith, params, next</span>) =&gt;</span> &#123;
      <span class="hljs-comment">// Applying flipping animations : read DOM before render, and flip after render</span>
      flipping.read();
      machineComponent.setState(
        &#123; <span class="hljs-attr">render</span>: React.createElement(renderWith, <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, params, &#123; next &#125;), []) &#125;,
        () =&gt; flipping.flip()
      );
    &#125;
  &#125;
...</code></pre>
<p>The previous code shows how to customize the rendering to run a function just before rendering and just after rendering. The rendering itself is triggered with <code>React.setState</code> (you should not change that part). <code>React.setState</code> accepts as second argument a callback which runs immediately after rendering is performed. We may in the future hide away the details of <code>React.setState</code> so as not to expose implementation details in the interface.</p>
<h4 id="Customizing-options"><a href="#Customizing-options" class="headerlink" title="Customizing options"></a>Customizing options</h4><p>Here we simply change the initial event that triggers the display of the initial screen:</p>
<pre><code class="hljs js">...
  options: &#123; <span class="hljs-attr">initialEvent</span>: [ <span class="hljs-string">"START"</span>] &#125;,
...</code></pre>
<h4 id="Command-handlers"><a href="#Command-handlers" class="headerlink" title="Command handlers"></a>Command handlers</h4><p>Command handlers receive three parameters: the event emitter, the params passed by the command they handle, and the effect handlers passed to the machine factory. The orchestration here simply consists of dealing with failing and successful effect execution:</p>
<pre><code class="lang-js">  ...
  commandHandlers: {
    [COMMAND_SEARCH]: (next, query, effectHandlers) =&gt; {
      effectHandlers
        .runSearchQuery(query)
        .then(data =&gt; {
          next([&quot;SEARCH_SUCCESS&quot;,data.items]);
        })
        .catch(error =&gt; {
          next([&quot;SEARCH_FAILURE&quot;, void 0]);
        });
    }
  },
  ...
};
</code></pre>
<h4 id="A-typical-machine-run"><a href="#A-typical-machine-run" class="headerlink" title="A typical machine run"></a>A typical machine run</h4><p>Alright, now let’s leverage the example to explain what is going on here together with the <code>&lt;Machine /&gt;</code> semantics.</p>
<p>First of all, we use <code>React.createElement</code> but you could just as well use jsx <code>&lt;Machine ... /&gt;</code>, that really is but an implementation detail. In our implementation, we are mostly using core React API and <a href="https://github.com/mlmorg/react-hyperscript" target="_blank" rel="noopener">hyperscript</a> rather than jsx. Then keep in mind that when we write ‘the  machine’, we refer to the state machine whose graph has been given previously. When we want to  refer to the <code>Machine</code> React component, we will always specifically precise that.</p>
<p>Our state machine is basically a function that takes an input and returns outputs. The inputs received by the machine are meant to be mapped to events triggered by the user through the user interface. The outputs from the machine are commands representing what commands/effects to perform on the interfaced system(s). The mapping between user/system events and machine input is performed by <code>preprocessor</code>. The commands output  by the machine are mapped to handlers gathered in <code>commandHandlers</code> so our <code>Machine</code>  component knows how to run a command when it receives one.</p>
<p>A run of the machine would then be like this :</p>
<ul>
<li>The machine will encapsulate the following properties as part of its extended state : <code>query</code>, <code>items</code>, <code>photo</code>. This extended state will be updated according to the machine specifications according to the input received by the machine and the control state the machine is in.  </li>
<li>The initial extended state is <code>{ query: &#39;&#39;, items: [], photo: undefined }</code></li>
<li>The machine transitions automatically from the initial state to the <code>start</code> control state.<ul>
<li>on doing so, it issues one command: render <code>GalleryApp</code>. Render commands have a default handler which renders the <code>renderWith</code> component passed as parameter with the <em>props</em> included in the render command. An event emitter (<code>next</code> in the code sample above) is passed to allow for the element to send events to the state machine.</li>
</ul>
</li>
<li>The <code>Machine</code> component executes the render command and renders a gallery app with an empty query text input, no images(<code>items</code>), and no selected image (<code>photo</code>).</li>
<li>The user enters some text in the text input</li>
<li>The user clicks the <code>Search</code> button. <ul>
<li>A <code>submit</code> event is triggered.</li>
<li>The value of the input field is read, and the <code>submit</code> event is transformed into a machine input <code>{SEARCH : &lt;query&gt;}</code> which is passed to the machine</li>
<li>The machine, per its specifications, outputs two commands: <code>COMMAND_SEARCH</code> and render <code>GalleryApp</code>, and transitions to <code>loading</code> control state </li>
<li>The <code>Machine</code> component executes the two commands: the gallery is rendered (this time with a <code>Cancel</code> button appearing), and an API call is made. Depending on the eventual result of that API call, the command handler will trigger a <code>SEARCH_SUCCESS</code> or <code>SEARCH_FAILURE</code> event.</li>
</ul>
</li>
<li>The search is successful: the <code>SEARCH_SUCCESS</code> event is transformed into a machine input <code>{SEARCH_SUCCESS: items}</code>. <ul>
<li>The machine, per its specifications, updates its extended state <code>items</code> property, and outputs a render <code>GalleryApp</code> command. This displays the list of fetched items on the screen.</li>
</ul>
</li>
<li>Any further event will lead to the same sequence: <ul>
<li>the user or an interfaced system (network, etc.) triggers an event X,</li>
<li>that event will be transformed into a machine input (as per <code>preprocessor</code>), </li>
<li>the machine will, as per its specs, update its extended state and issue command(s) </li>
<li>Issued commands will be executed by the <code>Machine</code> component, as per <code>commandHandlers</code></li>
</ul>
</li>
</ul>
<p>This is it! Whatever the machine passed as parameter to the <code>Machine</code> component, its behaviour will always be as described.</p>
<p>Note that this example is contrived for educational purposes:</p>
<ul>
<li>we could do away with the preprocessor and have the DOM event handlers directly produce inputs in the format accepted by the machine</li>
<li>we could handle concurrency issues (user makes a second search while the first search request is in-flight) either reusing Rxjs capabilities (<code>switchMap</code>) or at the machine level (extra piece of state)</li>
</ul>
<h3 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h3><p>Types  can be found in the <a href="https://github.com/brucou/react-state-driven/tree/master/types" target="_blank" rel="noopener">repository</a>. </p>
<h3 id="Contracts"><a href="#Contracts" class="headerlink" title="Contracts"></a>Contracts</h3><ul>
<li>command handlers delegate <strong>all effects on external systems</strong> through the effect handler module</li>
<li>the <code>COMMAND_RENDER</code> command is reserved and must not be used in the command handlers’ specifications</li>
<li>type contracts</li>
<li><code>next</code> is injected as a <em>prop</em> to the <code>renderWith</code> component and as such cannot be overridden by the component’s defined <em>props</em></li>
</ul>
<h2 id="Semantics"><a href="#Semantics" class="headerlink" title="Semantics"></a>Semantics</h2><ul>
<li>The <code>&lt;Machine /&gt;</code> component:<ul>
<li>initializes the raw event source (event handler) which receives and forwards all raw events (user events and system events)</li>
<li>creates a global command handler to dispatch to user-defined command handlers</li>
<li>connects the raw event source to the preprocessor</li>
<li>connects the preprocessor to the machine</li>
<li>connects the machine to the command handler</li>
<li>starts the machine: the machine is now reactive to raw events and computes the associated commands</li>
</ul>
</li>
<li>The preprocessor will receive raw events from two sources: the user interface and the external systems (databases, etc.). From raw events, it will compute inputs for the connected state machine. Note that:<ul>
<li>the preprocessor may perform effects only on the user interface (for instance <code>e =&gt; e.preventDefault()</code>)</li>
<li>the preprocessor may have its own internal state</li>
</ul>
</li>
<li>The machine receives preprocessed events from the preprocessor and computes a set of commands to be executed</li>
<li>The global command handler executes the incoming commands:<ul>
<li>if the command is a render command, the global handler executes directly the command in the context of the <code>&lt;Machine/&gt;</code> component</li>
<li>if the command is not a render command, the global handler dispatches the command to the user-configured command handlers</li>
</ul>
</li>
<li>All command handlers are passed three arguments: <ul>
<li>an event emitter connected to the raw event source</li>
<li>the parameters of the command they address</li>
<li>an object of type <code>EffectHandlers</code> which contains any relevant dependencies needed to perform effects (that is the object passed in props to the <code>&lt;Machine/&gt;</code> component)</li>
</ul>
</li>
<li>Render commands lead to the rendering of React components that feature DOM event handlers. Those event handlers can pass their raw events (DOM events) to the machine thanks to the raw event source emitter</li>
<li>Non-render commands lead to the execution of procedures which may be successful or fail. The command handler can pass back information to the machine thanks to the injected event emitter. </li>
<li>The event handler must be an object with a <strong>synchronous</strong> <code>next</code> method (<code>Observer</code> interface) and optionally a <code>subscribe</code> method (<code>Observable</code> interface)</li>
<li>The event source is terminated when the <code>&lt;Machine/&gt;</code> component is removed from the screen (<code>componentWillUnmount</code> lifecycle method)</li>
</ul>
<h2 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h2><p>We are going all along to refer to an image search application example to illustrate our argumentation. Cf. <a href="#example">Example section</a> for more details.</p>
<p>In a traditional architecture, a simple scenario would be expressed as follows:</p>
<figure class="fullwidth"><p><img src="https://imgur.com/AbCtBgn.png" alt="image search basic scenario"></p>
</figure>
<p>What we can derive from that is that the application is interfacing with other systems: the user interface and what we call external systems (local storage, databases, etc.). The application  responsibility is to translate user actions on the user interface into commands on the external systems, execute those commands, and deal with their result.</p>
<p>In our proposed architecture with all options used, the same scenario would become:</p>
<figure class="fullwidth"><p><img src="https://imgur.com/kdsOIV1.png" alt="image search basic scenario"></p>
</figure>
<p>In our proposed architecture with only mandatory options used, the same scenario would become:</p>
<figure class="fullwidth"><p><img src="https://imgur.com/iNGLUSw.png" alt="image search basic scenario"></p>
</figure>
<p>In that architecture, the application is refactored into a mediator, a preprocessor, a state machine, a command handler, and an effect handler. The application is thus split into smaller parts which address specific concerns:</p>
<ul>
<li>the preprocessor translates user interface events into inputs for the state machine</li>
<li>the state machine computes the commands to execute as a result of its present and past inputs, or, what is equivalent, its present input and current state </li>
<li>the command handler interprets and executes incoming commands, delegating the execution of effects to the effect handler when necessary</li>
<li>the mediator orchestrates the user interface, the preprocessor, the state machine, and the command handler</li>
</ul>
<p>While the architecture may appear more complex (isolating concerns means more parts), we have reduced the complexity born from the interconnection between the parts. </p>
<p>Concretely, we increased the testability of our implementation:</p>
<ul>
<li>the mediator algorithm is the same independently of the pieces it coordinates. This means it can be written and tested once, then reused at will. This is our <code>&lt;Machine /&gt;</code> component. <strong>This is glue code that you do not have to write and test anymore</strong></li>
<li>effect handlers are pretty generic pieces of code. An example could be code to fetch a resource. That code is written and tested once (and comes generally tested out of the box), and then reused for any resource. Additionally, only the effect handlers can perform effects on the external systems, which helps testing, tracing and debugging<sup><a href="#fn_3" id="reffn_3">3</a></sup></li>
<li>effect handlers, being isolated in their own module, are easy to mock, without resorting to complex machinery specific to a testing library</li>
<li>the state machine is a function which <strong>performs no effects</strong>, and whose output exclusively depends on the current state, and present input<sup><a href="#fn_2" id="reffn_2">2</a></sup>. We will use the term <em>causal</em> functions for such functions, in  reference to <a href="https://en.wikipedia.org/wiki/Causal_system" target="_blank" rel="noopener">causal systems</a>, which exhibit the same property<sup><a href="#fn_1" id="reffn_1">1</a></sup>. The causality property means state machines are a breeze to reason about and test (well, not as much as pure functions, but infinitely better than  effectful functions)</li>
<li>only the preprocessor and mediator can perform effects on the user interface, which helps testing, tracing and debugging </li>
</ul>
<p>We also have achieved greater modularity: our parts are coupled only through their interface. For instance, we use in our example below <code>Rxjs</code> for preprocessing events, and <a href="https://github.com/brucou/kingly" target="_blank" rel="noopener"><code>kingly</code></a> as state machine library. We could easily switch to <a href="https://github.com/cujojs/most" target="_blank" rel="noopener"><code>most</code></a> and <a href="https://github.com/davidkpiano/xstate" target="_blank" rel="noopener"><code>xstate</code></a> if the need be, or to a barebone event emitter (like <code>emitonoff</code>) by simply building interface adapters.</p>
<p>There are more benefits but this is not the place to go about them. Cf:</p>
<ul>
<li><a href="https://brucou.github.io/posts/user-interfaces-as-reactive-systems/">User interfaces as reactive systems</a></li>
<li><a href="https://rauchg.com/2015/pure-ui" target="_blank" rel="noopener">Pure UI</a></li>
<li><a href="https://medium.com/@asolove/pure-ui-control-ac8d1be97a8d" target="_blank" rel="noopener">Pure UI control</a></li>
</ul>
<blockquote id="fn_3">
<sup>3</sup>. Command handlers can only perform effects internally (for instance async. communication with the mediator)<a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_2">
<sup>2</sup>. In relation to state machines, it is the same to say that       an output depends exclusively on past and present inputs and that an output exclusively depends       on the current state, and present input.    <a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_1">
<sup>1</sup>. Another term used elsewhere is <em>deterministic</em> functions, but we       found that term could be confusing.<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<h2 id="Code-examples"><a href="#Code-examples" class="headerlink" title="Code examples"></a>Code examples</h2><p>For the impatient ones, you can directly review the available demos:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Code playground</th>
<th style="text-align:center">Machine</th>
<th style="text-align:center">Screenshot</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://codesandbox.io/s/ym8vpqm7m9" target="_blank" rel="noopener">TMDb movie search</a></td>
<td style="text-align:center"><img src="https://github.com/brucou/movie-search-app/raw/specs-all/article/movie%20search%20good%20fsm%20corrected%20flowchart%20no%20emphasis%20switchMap.png" alt="graph"></td>
<td style="text-align:center"><img src="https://github.com/brucou/movie-search-app/raw/specs-all/article/app%20screenshot%20query%20detail%20-%20success.png" alt="TMDb online interface screenshot"></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://codesandbox.io/s/flickr-search-app-with-kingly-qivl3?file=/src/index.js" target="_blank" rel="noopener">flickr image search</a></td>
<td style="text-align:center"><img src="./assets/image%20gallery%20state%20cat.png" alt></td>
<td style="text-align:center"><img src="https://i.imgur.com/mDQQTX8.png?1" alt="image search interface"></td>
</tr>
</tbody>
</table>
</div>
<h2 id="API-design-goals"><a href="#API-design-goals" class="headerlink" title="API design goals"></a>API design goals</h2><p>We want to have an integration that is generic enough to accommodate a large set of use cases, and specific enough to be able to take advantage as much as possible of the <code>React</code> ecosystem and API. Unit-testing should ideally be based on the specifications of the behaviour of the component rather than its implementation details, and leverage the automatic test generator of the underlying <code>kingly</code> library. In particular:</p>
<ul>
<li>it should be seamless to use both controlled and uncontrolled components</li>
<li>it should be possible to use without risk of interference standard React features like <code>Context</code></li>
<li>it should use the absolute minimum React features internally, in order to favor for instance a painless port to React copycats (Preact, etc.)</li>
<li>non-React functionalities should be coupled only through interfaces, allowing to use any suitable implementation</li>
<li>the specifics of the implementation should not impact testing (hooks, suspense, context, etc.)</li>
</ul>
<p>As a result of these design goals:</p>
<ul>
<li>we do not use React hooks, context, portal, fragments, <code>jsx</code>, and use the minimum React lifecycle hooks</li>
<li>the component user can of course use the whole extent of the API at disposal, those restrictions only concern our implementation of the <code>&lt;Machine /&gt;</code> component.</li>
<li>we defined interfaces for extended state updates (reducer interface), event processing (observer and observable interfaces).</li>
<li>any state machine implementation (including one that uses no dedicated library) can be substituted to our library provided that it respects the machine interface and contracts: <ul>
<li>the machine is implemented by a function</li>
<li>it takes a unique input parameter of the shape <code>{[event name]: event data}</code></li>
<li>it returns an array of commands</li>
<li>it produces no effects</li>
</ul>
</li>
<li>we use dependency injection to pass the modules responsible for effects to the <code>&lt;Machine /&gt;</code> component</li>
</ul>
<h2 id="Tips-and-gotchas"><a href="#Tips-and-gotchas" class="headerlink" title="Tips and gotchas"></a>Tips and gotchas</h2><h4 id="Preprocessor-usage"><a href="#Preprocessor-usage" class="headerlink" title="Preprocessor usage"></a>Preprocessor usage</h4><p>Most of the time <code>preprocessor</code> will just change the name of the event. You can perfectly if that makes sense, use <code>preprocessor : x =&gt; x</code> and directly pass on the raw events to the machine as input. That is fine </p>
<ul>
<li>as long as the machine never has to perform an effect (this is one of the machine’s contract). Furthermore, for documentation and design purposes, it may make sense to use any input   nomenclature which links to the domain rather than the user interface. As we have seen, what is   a <strong>button click</strong> on the interface is a <strong>search input</strong> for the machine, and results in a    <strong>search command</strong> to the command handler. </li>
<li>if the machine at hand is only designed for that user interface and not intended to be reused in any other context. This approach, as a matter of fact, couples the view to the machine. In the  case of our image gallery component, we could imagine a reusable parameterizable machine that implements the behaviour of a generic search input. Having a preprocessor enables us to integrate such machines without a hiccup.<ul>
<li>some machine inputs may correspond to the aggregation of several events (in advanced usage). For instance, if we had to recreate a double click for the <code>Search</code> button, we would have to receive two clicks before passing a <code>SEARCH</code> input to the machine. Having an <code>eventHandler</code> interface allows us to use <code>Rxjs</code> to deal with those cases, as its combinator library (<code>map</code>, <code>filter</code>, <code>takeUntil</code> etc.) allows us to aggregate events in a fairly simple manner. Note that we could implement this logic in the state machine itself (our machines are essentially Turing machines, they can implement any effect-less computation), but: </li>
</ul>
</li>
</ul>
<ol>
<li>it may be better to keep the machine dealing with inputs at a consistent level of   abstraction; </li>
<li>that kind of event aggregation is done easily enough with a dedicated library such as <code>rxjs</code></li>
</ol>
<h4 id="Handling-concurrent-commands"><a href="#Handling-concurrent-commands" class="headerlink" title="Handling concurrent commands"></a>Handling concurrent commands</h4><p>You may want to handle some concurrency issues at the machine level. Typically in our example, that would mean handling the user scenario when the user is requesting two different queries in rapid succession and the first query response has not arrived before the second query is executed. There is in this case a risk of the user interface displaying the wrong response.</p>
<p>You may alternatively want to do it at the command handler level to keep your machine at a higher level of abstraction. A command handler may for instance recreate Rxjs’s <code>switchMap</code> by keeping a record of in-flight queries.</p>
<h4 id="Communication-with-other-components"><a href="#Communication-with-other-components" class="headerlink" title="Communication with other components"></a>Communication with other components</h4><p>The interfaced systems can communicate with the machine via an event emitter. The <code>props.renderWith</code> React component is injected a <code>next</code> <em>prop</em> which is an event emitter that relays events to the machine’s raw event source. Using the <code>next</code> prop in DOM event handlers allows the machine to receive DOM events. Command handlers are also passed the <code>next</code> event emitter, and can use it to send to the machine any messages from the interfaced systems. </p>
<p>A third usage, not illustrated in the demos, is to pass events that originate from outside the component. If there is another component somewhere in the component tree that needs to communicate with the <code>&lt;Machine /&gt;</code> component, it can do see through the <code>next</code> prop. In this case, the <code>next</code> prop will be created and passed to both components which needs communicating.</p>
<p>The same technique can of course be used to pass events from the machine to another component. In this particular use case however, it is also possible to use an effect handler which emits <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events" target="_blank" rel="noopener">custom DOM events</a>. The difference between the two techniques lies in the increased control over which components receive the event that the developer has when using the <code>next</code> prop. Using a custom DOM event however decouples further the machine from its context of use (imagine a generic, reusable machine).</p>

  
  
  <div class="footer">
    <a id="follow-button" class="btn" title="Kingly Github" href="https://github.com/brucou/kingly">
      <img class="github" src="/documentation/images/GitHub-Mark-32px.png" alt="github">
    </a>
    <a id="follow-button" class="btn" title="Follow Kingly on Twitter" href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fbrucou.github.io/documentation%2F&amp;ref_src=twsrc%5Etfw&amp;region=follow_link&amp;screen_name=bricoi1&amp;tw_p=followbutton">
      <img class="twitter" src="/documentation/images/icons8-twitter-48.png" alt="twitter">
    </a>
  </div>
</div>

      </div>
      <script src="/documentation/js/smooth-scroll.min.js"></script>
    

    <!-- script for sidebars, version selects etc. -->
    <script src="/documentation/js/css.escape.js"></script>
    <script src="/documentation/js/common.js"></script>
    <!-- mathjax-->
    <script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->


</body>
</html>
