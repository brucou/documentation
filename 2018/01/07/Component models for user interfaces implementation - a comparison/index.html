

<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><title>Component models for user interfaces implementation - a comparison — Kingly.js</title>
  <meta charset="utf-8">
  <meta name="description" content="Kingly - The Modelling Library for Portable UIs">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

  <meta property="og:type" content="article">
  <meta property="og:title" content="Component models for user interfaces implementation - a comparison — Kingly.js">
  <meta property="og:description" content="Kingly - The Modelling Library for Portable UIs">
  <meta property="og:image" content="https://brucou.github.io/documentation//documentation/images/kingly_logo.png">
  <!-- Twitter -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Component models for user interfaces implementation - a comparison — Kingly.js">
  <meta name="twitter:description" content="Kingly - The Modelling Library for Portable UIs">
  <meta name="twitter:image" content="https://brucou.github.io/documentation/images/kingly_logo.png">

  <link rel="apple-touch-icon" sizes="180x180" href="/documentation/images/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/documentation/images/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="256x256" href="/documentation/images/icons/favicon-256x256.png">
  <link rel="icon" href="/documentation/images/kingly_logo.png" type="image/png">

  <link href="//fonts.googleapis.com/css?family=Lato:300,400,600" rel="stylesheet" type="text/css">
  <link href="//fonts.googleapis.com/css?family=Overlock:400&text=Kingly.js" rel="stylesheet" type="text/css">

  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

  <!-- main page styles -->
  <link rel="stylesheet" href="/documentation/css/page.css">

  <!--<script src="/documentation/js/kingly.js"></script>-->

  <!-- ga -->
  <script>
    (function (i, s, o, g, r, a, m) {
      i['GoogleAnalyticsObject'] = r;
      i[r] = i[r] || function () {
        (i[r].q = i[r].q || []).push(arguments)
      }, i[r].l = 1 * new Date();
      a = s.createElement(o),
        m = s.getElementsByTagName(o)[0];
      a.async = 1;
      a.src = g;
      m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

    ga('create', 'UA-141924019-1', 'brucou.github.io/documentation');
    ga('send', 'pageview');
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  </head>

  <body class="docs">    <div id="mobile-bar">
      <!-- hexo-inject:begin --><!-- hexo-inject:end --><a class="menu-button"></a>
      <a class="logo" href="/documentation"></a>
    </div>
    

<div id="header">
  <a id="logo" href="/documentation/">
    <img src="/documentation/images/kingly_logo.png" alt="library logo">
    <span>Kingly</span>
    
  </a>
  <ul id="nav">
    <li class="nav-dropdown-container learn">
  <a class="nav-link">Learn</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li>
      <ul>
        <li><a href="/documentation/v1/concepts/" class="nav-link">Concepts</a></li>
        <li><a href="/documentation/v1/tutorials/" class="nav-link">Tutorials</a></li>
        <li><a href="/documentation/v1/examples/" class="nav-link">Examples</a></li>
        <li><a href="/documentation/v1/cookbook/" class="nav-link">Cookbook</a></li>
        <li><a href="/documentation/v1/best-practices/" class="nav-link">Best practices</a></li>
      </ul>
    </li>
  </ul>
</li>

<li>
  <a href="/documentation/v1/api/index.html" class="nav-link team">API</a>
</li>
<li class="nav-dropdown-container tooling">
  <a class="nav-link">Tooling</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li>
      <ul>
        <li><a href="/documentation/v1/tooling/tools_overview.html" class="nav-link">Overview</a></li>
        <li><a href="/documentation/v1/tooling/graph_editing.html" class="nav-link">Graph editing</a></li>
        <li><a href="/documentation/v1/tooling/compiling.html" class="nav-link">Compiling</a></li>
        <li><a href="/documentation/v1/tooling/devtool.html" class="nav-link">Devtool</a></li>
      </ul>
    </li>
  </ul>
</li>

<li class="nav-dropdown-container integrations">
  <a class="nav-link">Integrations</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li>
      <ul>
        <li><a href="/documentation/v1/int-vanilla/" class="nav-link">Vanilla js</a></li>
        <li><a href="/documentation/v1/int-react/" class="nav-link">React</a></li>
        <li><a href="/documentation/v1/int-vue/" class="nav-link">Vue</a></li>
        <li><a href="/documentation/v1/int-svelte/" class="nav-link">Svelte</a></li>
        <li><a href="/documentation/v1/int-others/" class="nav-link">Others</a></li>
      </ul>
    </li>
  </ul>
</li>

<li>
  <a href="/documentation/v1/testing/index.html" class="nav-link team">Testing</a>
</li>
<li>
  <a href="/documentation/v1/contributed/index.html" class="nav-link team">Contributed</a>
</li>

  </ul>
</div>

    
      <div id="main" class="fix-sidebar">
          
  <div class="sidebar">
    <ul class="main-menu">
      <li class="nav-dropdown-container learn">
  <a class="nav-link">Learn</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li>
      <ul>
        <li><a href="/documentation/v1/concepts/" class="nav-link">Concepts</a></li>
        <li><a href="/documentation/v1/tutorials/" class="nav-link">Tutorials</a></li>
        <li><a href="/documentation/v1/examples/" class="nav-link">Examples</a></li>
        <li><a href="/documentation/v1/cookbook/" class="nav-link">Cookbook</a></li>
        <li><a href="/documentation/v1/best-practices/" class="nav-link">Best practices</a></li>
      </ul>
    </li>
  </ul>
</li>

<li>
  <a href="/documentation/v1/api/index.html" class="nav-link team">API</a>
</li>
<li class="nav-dropdown-container tooling">
  <a class="nav-link">Tooling</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li>
      <ul>
        <li><a href="/documentation/v1/tooling/tools_overview.html" class="nav-link">Overview</a></li>
        <li><a href="/documentation/v1/tooling/graph_editing.html" class="nav-link">Graph editing</a></li>
        <li><a href="/documentation/v1/tooling/compiling.html" class="nav-link">Compiling</a></li>
        <li><a href="/documentation/v1/tooling/devtool.html" class="nav-link">Devtool</a></li>
      </ul>
    </li>
  </ul>
</li>

<li class="nav-dropdown-container integrations">
  <a class="nav-link">Integrations</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li>
      <ul>
        <li><a href="/documentation/v1/int-vanilla/" class="nav-link">Vanilla js</a></li>
        <li><a href="/documentation/v1/int-react/" class="nav-link">React</a></li>
        <li><a href="/documentation/v1/int-vue/" class="nav-link">Vue</a></li>
        <li><a href="/documentation/v1/int-svelte/" class="nav-link">Svelte</a></li>
        <li><a href="/documentation/v1/int-others/" class="nav-link">Others</a></li>
      </ul>
    </li>
  </ul>
</li>

<li>
  <a href="/documentation/v1/testing/index.html" class="nav-link team">Testing</a>
</li>
<li>
  <a href="/documentation/v1/contributed/index.html" class="nav-link team">Contributed</a>
</li>

    </ul>
  </div>

<div class="content  ">
  
  
    <h1>Component models for user interfaces implementation - a comparison</h1>
  
  
    <h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p> In the previous articles, we have presented our proposed component model for user interfaces<br> implementation, which relies on a cyclejs architecture, and is based on streams and reactive<br> programming techniques.</p>
<p> We will, in this article, compare our proposed component model to <code>Angular2</code> and <code>React</code> component<br> models<sup><a href="#fn_notCycle" id="reffn_notCycle">notCycle</a></sup> along a few axes. The comparison will help us identify areas for future work :<br>  tooling, testing, and concurrency model.</p>
<blockquote id="fn_notCycle">
<sup>notCycle</sup>. We will not compare it to <code>cyclejs</code> component model as we estimate it does not have a proper one : while it is possible to breakdown a component into smaller components, there is no generic or structured mechanism to glue them together —- it has to be done manually each time. In addition, standard <code>cyclejs</code> conflates the interfaces with the external systems (<code>sources</code>) with the parameterization of components (for instance adding miscellaneous <code>prop$</code> source). It is precisely for that reason that we have come to propose our componentization model.<a href="#reffn_notCycle" title="Jump back to footnote [notCycle] in the text."> &#8617;</a>
</blockquote>
<h1 id="Angular2-component-model"><a href="#Angular2-component-model" class="headerlink" title="Angular2 component model"></a>Angular2 component model</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>A component controls a patch of screen called a view. You define a component’s application logic—what it does to support the view—inside a class.  You define a component’s view with its companion template. A template is a form of HTML that tells Angular how to render the component. A template looks like regular HTML, except for a few differences. The class interacts with the view through an API of properties and methods.  To tell Angular that a class is a component, you must attach metadata to the class. In TypeScript, you attach metadata by using a decorator. </p>
<p>An Angular2 template, in addition to HTML syntax, includes, among other things, the following<br>features:</p>
<ul>
<li><a href="https://angular.io/guide/template-syntax#binding-syntax-an-overview" target="_blank" rel="noopener">data binding</a> — includes<br>(property|attribute|class|style) binding, event binding, and two-way binding</li>
<li><a href="https://angular.io/guide/template-syntax#template-expressions" target="_blank" rel="noopener">template expressions</a> — expressions evaluated in the <a href="https://angular.io/guide/template-syntax#expression-context" target="_blank" rel="noopener">component instance’s context</a>, which produce a value that is assigned to a binding target. Template expressions are written in a language that looks like JavaScript.</li>
<li><a href="https://angular.io/guide/template-syntax#template-statements" target="_blank" rel="noopener">template statements</a> — evaluated in the <a href="https://angular.io/guide/template-syntax#statement-context" target="_blank" rel="noopener">component instance’s context</a>, responds to an event raised by a binding target such as an element, component, or directive.</li>
<li>Structural directives (<code>ngFor</code>, <code>ngIf</code>, <code>ngSwitch</code>, etc.) — change the DOM layout by adding and<br>removing DOM elements</li>
<li>Attribute directives — change the appearance or behavior of an element, component, or another<br>directive (<code>ngStyle</code>, etc.)</li>
</ul>
<p>The key methods/decorators for a component’s class are the following :</p>
<ul>
<li>inputs admitted by the component</li>
<li>output produced by the component</li>
<li>lifecycle methods : <code>constructor</code>, <code>ngOnDestroy</code>, <code>ngOnInit</code></li>
<li>event handlers</li>
</ul>
<p>The key metadata to attach to make a class into a component are : </p>
<ul>
<li>the selector which will hold the view</li>
<li>the template which specifies the view</li>
<li>the providers which are services (read : functions tackling the concerns not related to displaying the view). Services can be injected</li>
<li>component directives, which includes other components the declared component will require</li>
</ul>
<p>Better than words, here are some sample code from the Angular2 implementation of the project<br>management <a href="https://github.com/PacktPublishing/Mastering-Angular-2-Components" target="_blank" rel="noopener">sample application</a> we dealt with in a <a href="/posts/applying-componentization-to-reactive-systems---sample-application/">previous article</a>.</p>
<p><strong>Example of component’s class</strong></p>
<pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;
  <span class="hljs-comment">// We use the data provider to obtain a data change observer</span>
  <span class="hljs-keyword">constructor</span>(@Inject(ProjectService) projectService) &#123;
    <span class="hljs-keyword">this</span>.projectService = projectService;
    <span class="hljs-keyword">this</span>.projects = [];

    <span class="hljs-comment">// Setting up our functional reactive subscription to receive project changes from the database</span>
    <span class="hljs-keyword">this</span>.projectsSubscription = projectService.change
      <span class="hljs-comment">// We subscribe to the change observer of our service and deal with project changes in the function parameter</span>
      .subscribe(<span class="hljs-function">(<span class="hljs-params">projects</span>) =&gt;</span> &#123;
        <span class="hljs-keyword">this</span>.projects = projects;
        <span class="hljs-comment">// We create new navigation items for our projects</span>
        <span class="hljs-keyword">this</span>.projectNavigationItems = <span class="hljs-keyword">this</span>.projects
          .filter(<span class="hljs-function">(<span class="hljs-params">project</span>) =&gt;</span> !project.deleted)
          .map(<span class="hljs-function">(<span class="hljs-params">project</span>) =&gt;</span> &#123;
            <span class="hljs-keyword">return</span> &#123;
              <span class="hljs-attr">title</span>: project.title,
              <span class="hljs-attr">link</span>: [<span class="hljs-string">'/projects'</span>, project._id]
            &#125;;
          &#125;);
        <span class="hljs-comment">// Uses functional reduce to get a count over open tasks across all projects</span>
        <span class="hljs-keyword">this</span>.openTasksCount = <span class="hljs-keyword">this</span>.projects
          .reduce(<span class="hljs-function">(<span class="hljs-params">count, project</span>) =&gt;</span> count + project.tasks.filter(<span class="hljs-function">(<span class="hljs-params">task</span>) =&gt;</span> !task.done).length, <span class="hljs-number">0</span>);
      &#125;);
  &#125;

  <span class="hljs-comment">// If this component gets destroyed, we need to remember to clean up the project subscription</span>
  ngOnDestroy() &#123;
    <span class="hljs-keyword">this</span>.projectsSubscription.unsubscribe();
  &#125;
&#125;</code></pre>
<p><strong>Example of component declaration</strong></p>
<pre><code class="hljs javascript">@Component(&#123;
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'ngc-app'</span>,
  template,
  <span class="hljs-attr">directives</span>: [Project, Navigation, NavigationSection, NavigationItem, ROUTER_DIRECTIVES],
  <span class="hljs-attr">providers</span>: [ProjectService, UserService, ActivityService, TagsService]
&#125;)</code></pre>
<p>The interaction between the view defined in the template, and the class is performed through an<br>extensive and complex API, which includes, among other things, binding inputs, outputs,<br>and events.</p>
<p><strong>Example of template with bindings</strong></p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"app"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"app__l-side"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">ngc-navigation</span> [<span class="hljs-attr">openTasksCount</span>]=<span class="hljs-string">"openTaskCount"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ngc-navigation-section</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"Main"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ngc-navigation-item</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"Dashboard"</span> [<span class="hljs-attr">link</span>]=<span class="hljs-string">"['/dashboard']"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ngc-navigation-item</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ngc-navigation-section</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ngc-navigation-section</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"Projects"</span>
                            [<span class="hljs-attr">items</span>]=<span class="hljs-string">"projectNavigationItems"</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ngc-navigation-section</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ngc-navigation-section</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"Admin"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ngc-navigation-item</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"Manage Plugins"</span> [<span class="hljs-attr">link</span>]=<span class="hljs-string">"['/plugins']"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ngc-navigation-item</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ngc-navigation-section</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">ngc-navigation</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"app__l-main"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">router-outlet</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-outlet</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>Note how the template binds together the view, the class and the component, into a cohesive whole,<br>and relate to each other’s entities :</p>
<ul>
<li>standard HTML elements describe the view (<code>div</code>, etc.)</li>
<li><code>ngc-navigation</code> relates to the <code>Navigation</code> component, passed as a directive to the <code>App</code><br>component</li>
<li><code>openTasksCount</code> from the <code>App</code> class is passed as <em>live</em> input to <code>ngc-navigation</code> (data binding with the <code>[]</code> syntax). This means that whenever <code>openTasksCount</code> will change, the <code>ngc-navigation</code> will adjust to that new value. This is by the way a typical case of parent-child communication via inputs</li>
</ul>
<p>The corresponding extract of the code for the <code>Navigation</code> component should illustrate the use of<br> the <code>@Input</code> decorator to bind the parameters passed in the template to properties of the<br> corresponding class :</p>
 <pre><code class="hljs javascript">@Component(&#123;
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'ngc-navigation'</span>,
  template,
  <span class="hljs-attr">directives</span>: [NavigationSection, UserArea]
&#125;)
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Navigation</span> </span>&#123;
  @Input() openTasksCount;
&#125;</code></pre>
<p>Because of the coupling between template, class and component, none of those entities can be, a priori, reasoned about individually. As a result, in all what follows when we will refer to a component, unless otherwise specified, we will mean the triple (template, class, @component).</p>
<p>The ease of reasoning, or understanding, i.e. the readability of an Angular2 application will largely be a function of the component breakdown adopted, and the complexity of the interaction between components, and the complexity of the component definition itself.</p>
<h2 id="Application-architecture"><a href="#Application-architecture" class="headerlink" title="Application architecture"></a>Application architecture</h2><p>The primary responsibility of a Angular2 component is to display a view described by a template. </p>
<p>Templates bind events to event handler, which are located in the component’s class. Change<br>propagation and state management is performed by binding between template syntactic elements and<br>the class properties. As such a class has three key responsibilities : state management, event<br>handling, and lifecycle management.</p>
<p>The component declaration concerns itself with linking the component to the Angular2 framework,<br>so it can be handled and integrated with the rest of the components.</p>
<p>While being highly prescriptive about syntax (and there is a lot of new syntax), the Angular2<br>component architecture is relatively flexible in terms of the paradigms that it supports. In its<br>simplest expression, events are associated to action handlers, which directly modify local<br>component state, which in turn updates the view. It is however possible to follow functional reactive programming principles to <a href="https://vsavkin.com/managing-state-in-angular-2-applications-caf78d123d02" target="_blank" rel="noopener">some extent</a>, to <a href="https://github.com/ngrx/platform" target="_blank" rel="noopener">a larger extent</a> or simply adopt a redux-like <a href="https://blog.angular-university.io/angular-2-application-architecture-building-applications-using-rxjs-and-functional-reactive-programming-vs-redux/" target="_blank" rel="noopener">one-way data flow</a>.</p>
<h2 id="Component-interaction"><a href="#Component-interaction" class="headerlink" title="Component interaction"></a>Component interaction</h2><p>The <a href="https://angular.io/guide/component-interaction" target="_blank" rel="noopener">Angular2 documentation</a> lists 4<br>communication methods between components : </p>
<ul>
<li><a href="https://angular.io/guide/component-interaction#pass-data-from-parent-to-child-with-input-binding" target="_blank" rel="noopener">Pass data from parent to child with input binding</a></li>
<li><a href="https://angular.io/guide/component-interaction#parent-listens-for-child-event" target="_blank" rel="noopener">Parent listens for child event</a><ul>
<li>the implicit pub/sub mechanism associated (linked to the <code>@Output</code> decorator) can also be<br>used to communication between components in different hierarchies, i.e components which are not<br>in a ancestor/child relationship</li>
</ul>
</li>
<li><a href="https://angular.io/guide/component-interaction#parent-and-children-communicate-via-a-service" target="_blank" rel="noopener">Parent and children communicate via a service</a><ul>
<li>this is equivalent to communication by shared state, except that the service forms a facade<br>which handles the state update logic</li>
</ul>
</li>
<li>Parent owns an instrumentable reference to its child<ul>
<li><a href="https://angular.io/guide/component-interaction#parent-interacts-with-child-via-local-variable" target="_blank" rel="noopener">interacts with child via local variable</a><ul>
<li>a reference variable is created at the child level</li>
</ul>
</li>
<li><a href="https://angular.io/guide/component-interaction#parent-calls-an-viewchild" target="_blank" rel="noopener">Parent calls an <code>@ViewChild</code></a><ul>
<li>this allows the parent to own a reference of its children and directly instrument the<br>children, for instance to modify its state</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Routing"><a href="#Routing" class="headerlink" title="Routing"></a>Routing</h2><p>The Angular Router enables navigation from one view to the next as users perform application tasks. The router configuration has its own dedicated syntax (directives, decorators, etc.) and <a href="https://angular.io/guide/router#a-crisis-center-with-child-routes" target="_blank" rel="noopener">recommended pattern</a>. Learning to use routing hence requires learning new syntax and building a specific mental model. This leads to a fair amount of syntax to understand but also to produce, and a significant lead time to getting up-to-speed. On the bright side, the router comes already packaged with most of the features one will ever need in a web application.</p>
<h2 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h2><p>Angular creates, updates, and destroys components automatically as the user moves through the application. The app’s programmer can take action at each moment in this lifecycle through optional lifecycle hooks, like <code>ngOnInit</code>. </p>
<h2 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h2><p>Isolated unit tests examine an instance of a class all by itself without any dependence on Angular or any injected values. The tester creates a test instance of the class with new, supplying test doubles for the constructor parameters as needed, and then probes the test instance API surface.</p>
<p>Isolated unit tests should be written for pipes and services.</p>
<p>Components may be tested in isolation as well. However, isolated unit tests don’t reveal how components interact with Angular. In particular, they can’t reveal how a component class interacts with its own template or with other components.</p>
<p>Such tests require the Angular testing utilities. The Angular testing utilities include the <code>TestBed</code> class and several helper functions from <code>@angular/core/testing</code>. Writing Angular2 tests again requires learning (and producing) a great deal of new syntax and constructing yet another mental model.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p><code>Angular2</code> as a framework has a very large scope, and covers the large majority of the needs of<br> the web application programmer. However, this plethora of features comes with the cost of<br> a large incidental complexity. <strong>There are many parts</strong> (<code>Angular2</code> framework architecture,<br> component model, routing, templating, change detection, etc.), <strong>every part is complex</strong> on its<br> own, and then that complexity is <strong>compounded by the inter-relation</strong> or dependencies between the parts. That complexity means a significant time is required to construct the required mental models to understand and produce <code>Angular2</code> code. That complexity also multiplies the possibility of errors in the system’s implementation and may significantly increase debugging time. All those factors negatively impact productivity.</p>
<p>A good example of complexity generated by inter-related parts is the templating mechanism, <strong>a<br>double-edged sword.</strong> On the one hand, it makes the view contents more readable, specially to people with little coding experience (designers, etc.). On the other hand, the templating language precisely excels at expressing the view content, not at expressing logic and control-flow (loops, branching, etc.). The resulting DSL has a peculiar syntax, is not<br> Turing-complete, which forces to complement it with a general purpose language. That makes two languages to master, the peculiarities of the interface between the two to understand, two tightly coupled files (<code>.html</code> for the view and <code>.ts</code> for the logic) themselves coupled to the router, with what can be significant back-and-forth between the two to fully grasp the view’s behaviour. This impacts negatively both readability and productivity.</p>
<p>Another source of complexity is the inter-relation between components. For one thing, parent component can directly access and<br>instrument their children, which can make it a nightmare to reason about state in a complex<br>application. Then, depending on the state management strategy adopted, reconstructing the flow of data can be challenging in large component trees. Every component may have its own state, its own bindings and eventing to<br>parent component or any level in the component tree. They can also communicate with the parent via a service (i.e. shared state at the closest common ancestor level). State is then scattered among the application in<br>miscellaneous places, in miscellaneous programming artefacts, with both hidden and explicited<br>dependencies between pieces of state to be aware of, and it may be a arduous process to link all the pieces together. Once again, we are in a situation with <strong>many inter-related parts</strong>, which drives the complexity.<br>This can be mitigated by following a strong discipline about state management (one-way dataflow,<br>single store, reactive programming, etc.), and <strong>documentation</strong>, but this is on the programmer’s onus. A lot of the complexity is inherent to the framework and has be to assumed.</p>
<p>In summary, Angular2 is without a doubt a <strong>superb piece of technology</strong>. It often addresses<br>efficiently most of the issues a developer must resolve when implementing a user interface. By doing so, it removes a source of incidental complexity through its abstractions (browser quirks, synchronizing state and view,<br>routing, animation, performance, multi-platform targetting, etc.). However it also adds new<br>complexity linked to the number of inter-related concepts/parts which have to be mastered, and the complexity of each of those parts. Taming that complexity will require <strong>considerable discipline</strong> on the side of the developer(s), <strong>good<br>architecting</strong> on the side of the technical leadership, and the same level of <strong>supporting tools</strong><br>(CLI, visualizing component trees, router trees, inspecting component’s properties, etc.) available for the DSL than for the core language. There will be projects where resorting to <code>Angular2</code> does reduce the complexity more than it increases it. Large-scale, enterprise projects might fall in that category —- few user-interface tricks, mostly workflow driven, complexity resides in the domain, more than in the user interface. There will also be projects where <code>Angular2</code> will bring more problems than it<br> will solve.</p>
<h1 id="React-component-model"><a href="#React-component-model" class="headerlink" title="React component model"></a>React component model</h1><h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><p>Components let you split the UI into independent, reusable pieces, and think about each piece in isolation.<br>Conceptually, components are like JavaScript functions. They accept arbitrary inputs (called<br>“props”), a context (kind of global variable), and return React elements describing what should<br>appear on the screen. Components can be defined either as a function (termed functional components) or as a class.</p>
<p><strong>functional component</strong></p>
<pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Welcome</span>(<span class="hljs-params">props, context</span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
&#125;</code></pre>
<p><strong>class-based component</strong></p>
<pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Welcome</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;
  render() &#123;
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
  &#125;
&#125;</code></pre>
<p>Components can be composed simply by referring to other components in their output. With the help<br> of the <code>JSX</code> DSL, we for instance can write :</p>
 <pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">return</span> (
    &lt;div&gt;
      &lt;Welcome name="Sara" /&gt;
      &lt;Welcome name="Cahal" /&gt;
      &lt;Welcome name="Edite" /&gt;
    &lt;/div&gt;
  );
&#125;
``` 

The `Welcome` component itself could be broken into several other components. This gives rise to 
a component tree, which JSX allows to express in a readable form (additional benefits are better 
error and warning messages). The same principle guiding a good component breakdown applies here :
 loosely-coupled, reusable components, assembled into cohesive parts (cf. [extracting components](https://reactjs.org/docs/components-and-props.html#extracting-components) from the documentation).

Generic components, which may admit an unspecified number or type of components, may also be 
drafted with the special property `props.children` which is akin to Angular2's  
`&lt;ng-content&gt;&lt;/ng-content&gt;`, or the slot mechanism (`&lt;slot&gt;&lt;/slot&gt;`) of [web components](https://developers.google.com/web/fundamentals/web-components/shadowdom#slots). This is equivalent to passing the 
enclosed content of a component as a parameter like any other. An example can be found in the 
React's [documentation](https://reactjs.org/docs/composition-vs-inheritance.html#containment).

The class-based version of components allow to express components which encapsulate state. State 
management is then handled through life-cycle hooks (`componentDidMount`, `componentWillUnmount`,
 etc.) and ad-hoc methods possibly calling `setState` to update the local state. This is for 
 instance the code for a `Clock`  component  updating every second.

```javascript
class Clock extends React.Component &#123;
  constructor(props) &#123;
    super(props);
    this.state = &#123;date: new Date()&#125;;
  &#125;

  componentDidMount() &#123;
    this.timerID = setInterval(
      () =&gt; this.tick(),
      1000
    );
  &#125;

  componentWillUnmount() &#123;
    clearInterval(this.timerID);
  &#125;

  tick() &#123;
    this.setState(&#123;
      date: new Date()
    &#125;);
  &#125;

  render() &#123;
    return (
      &lt;div&gt;
        &lt;h1&gt;Hello, world!&lt;/h1&gt;
        &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;
      &lt;/div&gt;
    );
  &#125;
&#125;
``` 

Note as the `tick` method updates local state, which automatically triggers the (re-)rendering of 
the clock. 

There are peculiarities to state update, but they are few : [state update may be asynchronous](https://reactjs.org/docs/state-and-lifecycle.html#state-updates-may-be-asynchronous), and
 [state updates are merged](https://reactjs.org/docs/state-and-lifecycle.html#state-updates-are-merged). 

## Application architecture
Stateful components, i.e. components which manage their state, can be defined through classes. 
That class may hold event handlers, and other methods which directly and imperatively update the 
component's local state, triggering an update of the user interface. The `setState` accept a 
`prevState` parameter which allows to incrementally update the local state (vs. building the 
full state each time).

Additionally, control flow may be expressed in regular `javascript`, in order to [conditionally 
display](https://reactjs.org/docs/conditional-rendering.html) components, or iterate over them. `JSX` also provides some specific syntax to that purpose. Displaying lists requires assigning a key to each item, key which must 
be [unique among siblings](https://reactjs.org/docs/lists-and-keys.html#keys-must-only-be-unique-among-siblings).

`JSX`, while close to regular HTML, has some specific syntax ([forms](https://reactjs.org/docs/forms.html), [event binding](https://reactjs.org/docs/handling-events.html)). There are however few specificities, the 
full syntax can be relatively quickly be acquired, and JSX can be [entirely discarded](https://reactjs.org/docs/react-without-jsx.html) if need be in favor of standard javascript.

React strongly encourages [composition over inheritance](https://reactjs.org/docs/composition-vs-inheritance.html), 
providing mechanisms to compose components which allow to avoid using class inheritance. 

There a few advanced React concepts ([type checking](https://reactjs.org/docs/typechecking-with-proptypes.html), [Refs](https://reactjs.org/docs/refs-and-the-dom.html), [Performance](https://reactjs.org/docs/optimizing-performance.html), [Fragments](https://reactjs.org/docs/fragments.html), [Portals](https://reactjs.org/docs/portals.html), 
[Error management](https://reactjs.org/docs/error-boundaries.html)). Each of them has however a 
small surface, combine simply with the key concepts, resulting in an overall manageable complexity.

## Component interaction
The [React documentation](https://reactjs.org/docs/) lists 3 communication 
methods between components : 

- [Pass data from parent to child with input binding](https://angular.io/guide/component-interaction#pass-data-from-parent-to-child-with-input-binding)
- [Children with parent via ''protected'' shared state and handlers](https://reactjs.org/docs/lifting-state-up.html)
  - this is akin to Angular's communication via services. The shared state is lifted up to the 
  closest common ancestor. The common ancestor passes both the shared state, and a handle to its 
  children through `props`, handle by which the shared state can be modified (has a closure over 
  the state, or access to the state via `this`). The passing of handlers reminisces of event 
  binding. However the mechanism is more private, as only the parent which passes the handler can
   be affected by that 'event'.
- components communicate between each other via global state
  - this may mean using the [`context` feature](https://reactjs.org/docs/context.html) of React, 
  and is [strongly discouraged](https://medium.com/react-ecosystem/how-to-handle-react-context-a7592dfdcbc).
  - another possibility is have a global store at the app level. This is where additional 
  libraries like `Redux` or `Mobx` come into play.

In all cases, React strongly encourages [one-way dataflow](https://reactjs.org/docs/state-and-lifecycle.html#the-data-flows-down) communication between components.

## Routing
Unlike `Angular2`, `React` routing does not require a pre-made list of routes to later integrate 
with the component tree. Routing is expressed by [regular components](https://reacttraining.com/react-router/web/guides/philosophy), and nested routing is just nesting components, like one would nest html's `div`. For instance :

```javascript
const App = () =&gt; (
  &lt;BrowserRouter&gt;
    &#123;/* here's a div */&#125;
    &lt;div&gt;
      &#123;/* here's a Route */&#125;
      &lt;Route path="/tacos" component=&#123;Tacos&#125;/&gt;
    &lt;/div&gt;
  &lt;/BrowserRouter&gt;
)

// when the url matches `/tacos` this component renders
const Tacos  = (&#123; match &#125;) =&gt; (
  // here's a nested div
  &lt;div&gt;
    &#123;/* here's a nested Route,
        match.url helps us make a relative path */&#125;
    &lt;Route
      path=&#123;match.url + '/carnitas'&#125;
      component=&#123;Carnitas&#125;
    /&gt;
  &lt;/div&gt;
)
```  

This is a very powerful mechanism, which only increases marginally complexity.

## Lifecycle
In the context of stateful components, classed must have lifecycle methods. This means lifecycle 
of the local state has to be handled by hand. However, the library automatically handles the 
lifecycle of the component itself, using the hooks to complement its task. 

## Testing
UI testing is a complex subject. It encompasses testing :

* UI structure : the view should have an expected structure as a function of its state (i.e. 
$view = f(state)$, where $f$ is a pure function)
* UI behaviour : some user action should lead to some system actions (remember the reactive 
equation $actions = f(state,events)$ where $f$ is a pure function) 
* UI visual appearance (style, look, etc.) (this can be done by directly comparing pixel by pixel
 the rendered DOM and the target DOM)

I will focus on structure and behaviour testing. React has two main available tools to that 
purpose : `Jest` and `Enzyme`. Both allow to render a component with or without a DOM, and test 
its content for the expected structure. A `simulate` method allow to emit events 
and observe the resulting change in the UI. Mocks and spies can also be used. A summary of the 
techniques, mostly up-to-date, even if the article is old, can be found [here](http://reactkungfu.com/2015/07/approaches-to-testing-react-components-an-overview/). The testing of actions can be
 simplified with the use of `redux` and its derivated libraries.

## Conclusion
React is significantly less complex than Angular2 for two reasons. First of all, as a library, it 
takes on less responsibilities than a full-fledged framework like Angular2. Second, there are 
less parts to handle to build a react application, and each of those parts is relatively easy and
 quick to understand on its own, with clear and simple interaction with the other parts. 

For instance, the pseudo-templating technology used (`JSX`) is optional, and embeds nicely into 
 regular javascript code. All the power of the Turing-complete javascript logic can be used to 
 render a component while still enjoying the benefits of a HTML-like syntax when necessary. `JSX` 
 is easy (very few syntactic constructs above HTML) and cohesively located exactly where used, 
 instead of the file separation imposed by `Angular2`.

Furthermore, routing involves just regular components. There is very little new to learn to 
handle even nested routing. One-way dataflow simplifies state tracking. Similarly to Angular2, 
there are excellent dev tools which can be built for productivity gains.

The most complex aspect is probably testing. `Angular2` requires what seems like some fairly 
complex set-up in comparison with `React`, but does offer dependency injection. React is silent 
on the latter. As a result, it is possible that complex applications may be a la fine easier to 
test with `Angular2`. 

In fact, adding functionalities to React, means adding parts, and then adding 
complexity sources. The most common extra parts (`Redux`, `redux-thunk`, `redux-saga`), 
are in increasing order of complexity, and have to be integrated manually, together with their 
respective workflow and tooling. Other possible parts (animations, etc.) have to be evaluated. At equal perimeter of features, `React` still compares favorably to  `Angular2`, but the distance is lower. There will be teams and projects for which `Angular2` 
 will generate a higher value, precisely because it imposes uniform choices, and its set of 
 technologies is tightly integrated : that is the whole point of a framework.

# Our component model
## Description
Our component model is directly inspired by our functional approach to implement reactive 
systems, understood as a reactive function linking stream of events to stream of actions, and an 
interface with external systems to receive events and perform actions. A component in our model 
is a function with two arguments : `sources` and `settings`. The first argument is the interface to external 
systems' events and state. The second argument represents the component parametrization concern, 
and will allow to have generic components which can be specialized or parameterized through those 
settings. Components in our model compute the relevant system actions to perform, and pass the 
result of that computation to so-called **drivers**, which interface with the external systems to
 execute the relevant actions.  The computed actions are passed as an object whose every property
  (termed sink) represents a sequence of actions to be handled by the driver for that property.

Going back to our functional equations, a component implements a reactive function $f$ such that 
$actions = f(state, events)$. The  view update action can be shortened to $view = f(state)$, given that the only event which updates the  view is precisely a change of state, whose information is already included in the equation. In 
  short, we have :

$$\begin&#123;cases&#125;
   view &amp; = f_v(state) \\\\\
   actions &amp; = f_a(state, events)
\end&#123;cases&#125; $$

Here is an example of component illustrating all the previous points : 

```javascript
function NavigationItem(sources, settings) &#123;
  const &#123; url$ &#125; = sources;
  const &#123; project: &#123; title, link &#125; &#125; = settings;
  const linkSanitized = link.replace(/\//i, '_');

  const events = &#123;
    // NOTE : we avoid having to isolate by using the link which MUST be unique over the whole
    // application (unicity of a route)
    click : sources.DOM.select(`.navigation-section__link.$&#123;linkSanitized&#125;`).events('click')
  &#125;;
  const state$ = url$
    .map(url =&gt; url.indexOf(link) &gt; -1)
    .shareReplay(1);

  const actions = &#123;
    domUpdate : state$.map(isLinkActive =&gt; &#123;
      const isLinkActiveClass = isLinkActive ? '.navigation-section__link--active' : '';

      return a(
        `$&#123;isLinkActiveClass&#125;.navigation-item.navigation-section__link.$&#123;linkSanitized&#125;`,
        &#123; attrs: &#123; href: link &#125;, slot: 'navigation-item' &#125;,
        title)
    &#125;),
    router : events.click
      .do(preventDefault)
      .map(always('/' + link + '/'))
  &#125;

  return &#123;
    [DOM_SINK]: actions.domUpdate,
    router: actions.router
  &#125;
&#125;</code></pre>
<p>Note the 2 sinks, one for the DOM update driver, one for the router driver. The DOM update driver<br> receives the new DOM, computed only from <code>state$</code>.  The router driver receives the router<br> actions computed only from the events (reduced to <code>click</code> here). Last, note how fixed parameters<br> <code>{ project: { title, link } }</code> are passed to the <code>NavigationItem</code> component through <code>settings</code>.</p>
<h2 id="Application-architecture-1"><a href="#Application-architecture-1" class="headerlink" title="Application architecture"></a>Application architecture</h2><p>For DOM updates, a <a href="https://github.com/snabbdom/snabbdom" target="_blank" rel="noopener"><code>snabbdom</code></a> virtual DOM syntax is generally used. A virtual node is used for performance reasons. Writing the DOM as a function of state, means that we compute the full DOM<br>every time. Because it would be inefficient to directly display the new DOM, without reusing the<br>already displayed fragments of the current DOM, a virtual node mechanism allows to do a delta<br>between virtual DOM objects, and use that diff to compute and only update the portions of the DOM<br>that needs updating. Note that another syntax in which the dom updates are a function of the<br>state delta (i.e. $ view_{\Delta} = f(state_{\Delta}) $ ) is also possible (that is the model for instance<br>used by <a href="https://ractive.js.org/" target="_blank" rel="noopener"><code>Ractive</code></a>), but has not been investigated for the moment.</p>
<p>The actual syntax recognized for actions will vary for each driver, and as such should come as<br>part of the documentation for each driver. Drivers perform whatever action on external systems<br>which is part of their specification, and may produce a response, which is passed back into the<br>application via a property of the <code>sources</code> object named the same as the driver’s attributed sink.</p>
<p>Streams are commonly used when writing the application, allowing to write equations once, with<br>the runtime making sure that they keep in sync, by handling change propagation. This means in<br>particular that there is no need for lifecycle methods, and no need for imperative update of state.</p>
<p>The reactive functional programming core concepts are built on top of (here <code>rxjs</code>) streams.<br>Events are streams which are <code>shared</code>, behaviours are streams which are <code>shareReplayed(1)</code>.<br>Events modelize… events occuring in the system. Behaviours modelize pieces of state.<br>The adopted granularity of state will depend on the programmer’s design decision and<br>domain at hand. At one extreme, one single behaviour may keep all state in one place. At the other<br> extreme, dividing the application state in pieces may lead to having one behaviour for each piece.</p>
<p>As such, application architecture is rather simple (streams, events, behaviours, reactive<br>function, drivers are all the parts), though one could argue that the complexity of manipulating<br>state and events in a coordinated way has been transferred to that of understanding and<br>manipulating streams. However, because the stream manipulation has only to be learnt once, for any<br>sufficient large application, we posit that the stream abstraction should lower complexity by<br>eliminating the manual synchronization between events, state and actions. Last, because we write equations, it is<br>easy to reason about our component and application. </p>
<p>Furthermore, we propose a component model which allows to write an application as the aggregation<br> of smaller, easier to reason about applications. The reactive system under implementation is<br> deconstructed into a component tree, which is assembled by component combinators to give back<br> the target application. </p>
<p>Component combinators follow a syntax conceptually similar to <code>JSX</code>. For instance :</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> SidePanel =
  Combine(&#123;&#125;, [Div(<span class="hljs-string">'.app__l-side'</span>), [
    Navigation(&#123;&#125;, [
      NavigationSection(&#123; <span class="hljs-attr">title</span>: <span class="hljs-string">'Main'</span> &#125;, [
        NavigationItem(&#123; <span class="hljs-attr">project</span>: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">'Dashboard'</span>, <span class="hljs-attr">link</span>: <span class="hljs-string">'dashboard'</span> &#125; &#125;, [])
      ]),
      NavigationSection(&#123; <span class="hljs-attr">title</span>: <span class="hljs-string">'Projects'</span> &#125;, [
        InSlot(<span class="hljs-string">'navigation-item'</span>, [ListOfItemsComponent])
      ]),
      NavigationSection(&#123; <span class="hljs-attr">title</span>: <span class="hljs-string">'Admin'</span> &#125;, [
        NavigationItem(&#123; <span class="hljs-attr">project</span>: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">'Manage Plugins'</span>, <span class="hljs-attr">link</span>: <span class="hljs-string">'plugins'</span> &#125; &#125;, [])
      ]),
    ])
  ]]);</code></pre>
<p>is essentially equivalent to : </p>
<pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> SidePanel = 
  &lt;Div class='app__l-side'&gt;
    &lt;Navigation&gt;      
      &lt;NavigationSection title='Main'&gt;
        &lt;NavigationItem project=&#123; title: 'Dashboard', link: 'dashboard' &#125;/&gt;
      &lt;/NavigationSection&gt;
      &lt;NavigationSection title='Projects'&gt;
        &lt;Slot name='navigation-item'&gt;
          ...
        &lt;/Slot&gt;
      &lt;/NavigationSection&gt;
      &lt;NavigationSection title='Admin'&gt;
        &lt;NavigationItem project=&#123; title: 'Manage Plugins', link: 'plugins' &#125; /&gt;
      &lt;/NavigationSection&gt;
    &lt;/Navigation&gt;
  &lt;/Div&gt;</code></pre>
<p>This opens the door to a <code>JSX</code>-like DSL and many other optimizations in the future.</p>
<h2 id="Component-interaction-1"><a href="#Component-interaction-1" class="headerlink" title="Component interaction"></a>Component interaction</h2><p>There are 4 ways of interaction between components :</p>
<ul>
<li>Pass static (i.e. constants) parameterization data from parent to child with <code>settings</code><ul>
<li>this would be similar to the <code>props</code> passing in <code>React</code></li>
</ul>
</li>
<li>parent can inject state into children<ul>
<li>this fulfills a similar purpose to the <code>[]</code> binding syntax in <code>Angular2</code></li>
</ul>
</li>
<li>components communicate between each other via global state<ul>
<li>this means that a in-memory store driver could be used (à la <code>Redux</code>)</li>
</ul>
</li>
<li>components communicate between each other via events<ul>
<li>a component may send an event to a pub/sub driver, and another component might listen to it.<br>Note that while this pattern is possible, it is not often used in practice</li>
</ul>
</li>
</ul>
<h2 id="Routing-1"><a href="#Routing-1" class="headerlink" title="Routing"></a>Routing</h2><p>Routing can be realized through the <code>OnRoute</code> combinator and is inserted naturally at the<br>position of the component tree when the routing needs to occur. Routing can also be achieved<br>directly without the combinator though there will necessary be more boilerplate. As a matter of<br>fact, routing is matching a route change event to predefined component(s) actions, and as such<br>remains within the conceptual framework without modification.  </p>
<h2 id="Lifecycle-1"><a href="#Lifecycle-1" class="headerlink" title="Lifecycle"></a>Lifecycle</h2><p>There is no need for lifecycle management component-wise. Component are just functions. Events<br>and behaviours exists as long as they are necessary, and picked up by the runtime when there is<br>no more reference of them.</p>
<h2 id="Testing-1"><a href="#Testing-1" class="headerlink" title="Testing"></a>Testing</h2><p>Component can be tested via mocking of the interfaces with the external systems (<code>sources</code> and<br><code>drivers</code>). Given that the component tree is explicit, unit-testing a component involves :</p>
<ul>
<li>testing its children components</li>
<li>testing the parent component</li>
</ul>
<p>Testing children components before the parent allow to isolate bugs more quickly, and forces to<br>have a working specification of every component, which is a good practice. Unlike <code>Angular2</code>, the<br> children components are not injected, which means that they cannot be mocked or spyed on. This<br> in turns means that we cannot do white-box testing where we test that the parent component is<br> correctly calling its children component with the right arguments.</p>
<p> To test the parent, as any component, including the application, the main technique is to mock<br> the interface with the external input systems, i.e. <code>sources</code>, and the event streams which serve<br>  as input to the component under test. This requires that every driver author needs to supply, in<br> addition to the driver code, and documentation, a mock object. The complexity of testing will be<br>  directly linked to the complexity of configuring the necessary set of mock objects. The actions<br>   computed by the reactive function under the test can then be observed and compared with the<br>   expectd results (no need to mock the driver themselves).</p>
<p>  We have for instance made available a <code>document</code> driver, which is simply injecting the<br>  <code>document</code> object into the <code>sources</code> parameter. The mock version of the driver addresses common<br>   needs (such as simulating an event on a target element). However, a full mock would mean<br>   re-implementing large pans of the interface of <code>document</code> object, which is an error-prone,<br>   time-consuming endeavour.</p>
<p>   We have designed a <code>runTestScenario</code> helper which facilitates passing inputs, and analyzing<br>   outputs. Here are an example of tests written for a button component :</p>
<pre><code class="hljs javascript">QUnit.test(<span class="hljs-string">"Good settings : empty settings"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exec_test</span>(<span class="hljs-params">assert</span>) </span>&#123;
  <span class="hljs-keyword">const</span> done = assert.async(<span class="hljs-number">2</span>);

  <span class="hljs-keyword">const</span> testData = buttonTestSpace.GoodSettings.EmptySettings.caseEmpmtyAndTwoChildren;

  <span class="hljs-keyword">const</span> inputs = [
    &#123; [EVENT_SOURCE1]: &#123; <span class="hljs-attr">diagram</span>: <span class="hljs-string">'a-b-c|'</span>, <span class="hljs-attr">values</span>: eventSourcesTestValues &#125; &#125;,
    &#123; [EVENT_SOURCE2]: &#123; <span class="hljs-attr">diagram</span>: <span class="hljs-string">'-A-B-C|'</span>, <span class="hljs-attr">values</span>: eventSourcesTestValues &#125; &#125;,
    &#123;
      [<span class="hljs-string">`DOM!<span class="hljs-subst">$&#123;SOME_SELECTOR&#125;</span>@<span class="hljs-subst">$&#123;SOME_DOM_EVENT_NAME&#125;</span>`</span>]: &#123;
        <span class="hljs-attr">diagram</span>: <span class="hljs-string">'x-y-z'</span>, <span class="hljs-attr">values</span>: DOMeventsTestValuesSomeSelector
      &#125;
    &#125;,
    &#123;
      [<span class="hljs-string">`DOM!<span class="hljs-subst">$&#123;ANOTHER_SELECTOR&#125;</span>@<span class="hljs-subst">$&#123;ANOTHER_DOM_EVENT_NAME&#125;</span>`</span>]: &#123;
        <span class="hljs-attr">diagram</span>: <span class="hljs-string">'-x-y-z'</span>, <span class="hljs-attr">values</span>: DOMeventsTestValuesAnotherSelector
      &#125;
    &#125;,
  ];
  <span class="hljs-keyword">const</span> ATTRS = <span class="hljs-string">'tabindex="0"'</span>;

  <span class="hljs-keyword">const</span> testResults = &#123;
    [NON_DOM_SINK]: &#123;
      <span class="hljs-attr">outputs</span>: [
        <span class="hljs-string">`<span class="hljs-subst">$&#123;SEP&#125;</span> <span class="hljs-subst">$&#123;NON_DOM_SINK&#125;</span>-a`</span>, <span class="hljs-string">`<span class="hljs-subst">$&#123;SEP&#125;</span> <span class="hljs-subst">$&#123;NON_DOM_SINK&#125;</span>-A`</span>,
        <span class="hljs-string">`<span class="hljs-subst">$&#123;SEP&#125;</span> <span class="hljs-subst">$&#123;NON_DOM_SINK&#125;</span>-b`</span>, <span class="hljs-string">`<span class="hljs-subst">$&#123;SEP&#125;</span> <span class="hljs-subst">$&#123;NON_DOM_SINK&#125;</span>-B`</span>,
        <span class="hljs-string">`<span class="hljs-subst">$&#123;SEP&#125;</span> <span class="hljs-subst">$&#123;NON_DOM_SINK&#125;</span>-c`</span>, <span class="hljs-string">`<span class="hljs-subst">$&#123;SEP&#125;</span> <span class="hljs-subst">$&#123;NON_DOM_SINK&#125;</span>-C`</span>,
      ],
      <span class="hljs-attr">successMessage</span>: <span class="hljs-string">`sink <span class="hljs-subst">$&#123;NON_DOM_SINK&#125;</span> produces the expected values`</span>,
    &#125;,
    [DOM_SINK]: &#123;
      <span class="hljs-attr">outputs</span>: [
        <span class="hljs-string">`&lt;div class=\"ui button\" <span class="hljs-subst">$&#123;ATTRS&#125;</span>&gt;&lt;span&gt;<span class="hljs-subst">$&#123;DOM_SINK&#125;</span> <span class="hljs-subst">$&#123;SEP&#125;</span> a&lt;/span&gt;&lt;span&gt;<span class="hljs-subst">$&#123;DOM_SINK&#125;</span> <span class="hljs-subst">$&#123;SEP&#125;</span> a&lt;/span&gt;&lt;/div&gt;`</span>,
        <span class="hljs-string">`&lt;div class=\"ui button\" <span class="hljs-subst">$&#123;ATTRS&#125;</span>&gt;&lt;span&gt;<span class="hljs-subst">$&#123;DOM_SINK&#125;</span> <span class="hljs-subst">$&#123;SEP&#125;</span> b&lt;/span&gt;&lt;span&gt;<span class="hljs-subst">$&#123;DOM_SINK&#125;</span> <span class="hljs-subst">$&#123;SEP&#125;</span> a&lt;/span&gt;&lt;/div&gt;`</span>,
        <span class="hljs-string">`&lt;div class=\"ui button\" <span class="hljs-subst">$&#123;ATTRS&#125;</span>&gt;&lt;span&gt;<span class="hljs-subst">$&#123;DOM_SINK&#125;</span> <span class="hljs-subst">$&#123;SEP&#125;</span> b&lt;/span&gt;&lt;span&gt;<span class="hljs-subst">$&#123;DOM_SINK&#125;</span> <span class="hljs-subst">$&#123;SEP&#125;</span> b&lt;/span&gt;&lt;/div&gt;`</span>,
        <span class="hljs-string">`&lt;div class=\"ui button\" <span class="hljs-subst">$&#123;ATTRS&#125;</span>&gt;&lt;span&gt;<span class="hljs-subst">$&#123;DOM_SINK&#125;</span> <span class="hljs-subst">$&#123;SEP&#125;</span> c&lt;/span&gt;&lt;span&gt;<span class="hljs-subst">$&#123;DOM_SINK&#125;</span> <span class="hljs-subst">$&#123;SEP&#125;</span> b&lt;/span&gt;&lt;/div&gt;`</span>,
        <span class="hljs-string">`&lt;div class=\"ui button\" <span class="hljs-subst">$&#123;ATTRS&#125;</span>&gt;&lt;span&gt;<span class="hljs-subst">$&#123;DOM_SINK&#125;</span> <span class="hljs-subst">$&#123;SEP&#125;</span> c&lt;/span&gt;&lt;span&gt;<span class="hljs-subst">$&#123;DOM_SINK&#125;</span> <span class="hljs-subst">$&#123;SEP&#125;</span> c&lt;/span&gt;&lt;/div&gt;`</span>,
      ],
      <span class="hljs-attr">transform</span>: convertVNodesToHTML,
      <span class="hljs-attr">successMessage</span>: <span class="hljs-string">`sink <span class="hljs-subst">$&#123;DOM_SINK&#125;</span> produces the expected values`</span>,
    &#125;,
  &#125;;

  runTestScenario(inputs, testResults, makeButtonComponent(testData, &#123; <span class="hljs-attr">SEP</span>: SEP &#125;), &#123;
    <span class="hljs-attr">tickDuration</span>: <span class="hljs-number">5</span>,
    <span class="hljs-attr">waitForFinishDelay</span>: <span class="hljs-number">50</span>,
    <span class="hljs-attr">analyzeTestResults</span> : analyzeTestResults(assert, done),
    <span class="hljs-attr">mocks</span>: &#123;
      <span class="hljs-attr">DOM</span>: makeMockDOMSource
    &#125;,
    <span class="hljs-attr">sourceFactory</span>: &#123;
      [<span class="hljs-string">`DOM!<span class="hljs-subst">$&#123;SOME_SELECTOR&#125;</span>@<span class="hljs-subst">$&#123;SOME_DOM_EVENT_NAME&#125;</span>`</span>]: subjectFactory,
      [<span class="hljs-string">`DOM!<span class="hljs-subst">$&#123;SOME_SELECTOR&#125;</span>@<span class="hljs-subst">$&#123;ANOTHER_DOM_EVENT_NAME&#125;</span>`</span>]: subjectFactory,
    &#125;,
    <span class="hljs-attr">errorHandler</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;
      done(err)
    &#125;
  &#125;)
&#125;);</code></pre>
<p>Note the syntax <code>DOM!${SOME_SELECTOR}@${SOME_DOM_EVENT_NAME}</code> to simulate an event on an element<br>of a given selector. Note also the use of time diagrams to simulate a timed-sequence of inputs.</p>
<p>While this works, we believe that unit-testing a component is still a pain point, which must be<br>remediated further. Not having to mock the drivers is nice, but having to mock the <code>sources</code><br>generates some unavoidable complexity.</p>
<p>It is of course possible to test with an automation tool such as <code>selenium</code> which works with a<br>real DOM, just as with <code>Angular2</code> and <code>React</code>.</p>
<h2 id="Conclusion-1"><a href="#Conclusion-1" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>While <code>React</code> makes the view declarative ($view = f(state)$), our stream-based <code>cyclejs</code><br>architecture makes the whole application declarative ($actions = f (states, events)$). Streams<br>abstract out both asynchrony and change propagation, allowing to reason about a system<br>equationally. While there are architectures (<code>React</code> +<code>Redux</code>/<code>Thunk</code>/<code>Saga</code>; <code>Angular2</code> + <code>ngrx</code><br>and its large ecosystem) which seek to extend declarativeness beyond the view, we however feel pretty comfortable that we do this in a way <strong>fundamentally simpler</strong> than the previously mentioned library/framework.</p>
<p>We separate the action representation from the actual execution of the action, while both <code>React</code> and <code>Angular2</code> directly performs the actions triggered by user inputs. There are advantages to that which are not fully exploited yet. On the one hand, orchestrating actions (what <a href="https://github.com/redux-saga/redux-saga" target="_blank" rel="noopener"><code>redux-saga</code></a> does) becomes possible with a state machine (we offer the <code>FSM</code> combinator for this), which, while a low-level tool, compensates with its genericity. On the other hand, this simplifies testing by not having to mock action handlers.</p>
<h1 id="Conclusion-2"><a href="#Conclusion-2" class="headerlink" title="Conclusion"></a>Conclusion</h1><p><code>React</code> and <code>Angular2</code> are library/framework which are either full-featured or come with a<br>extensive list of complements (plugins, libraries, compilers, dev tools, etc.) tackling a lot of<br>the issues that developers face today. They recognize the value of the stream abstraction and<br>are flexible enough to allow for a limited but valuable use of abstractions and architectures<br>based on top of streams.  </p>
<p>Fully stream-based architectures, in comparison, are still in the infancy of their development and<br>have to be further developed to reach a similar stage of maturity.  In the web user-interface<br>space, <code>cyclejs</code> is such an architecture, on top of which we built our component model. We<br>believe that our component model makes for an easier way to write applications, but above all to<br>understand them, reason about them, and maintain them. The key reason behind our optimism is the<br>inherent declarativeness of our approach based on functional equations.</p>
<p>Nonetheless, a lot more must be done to make the life of the programmer easier. Among the top<br>priorities is the development of productivity tooling : </p>
<ol>
<li>Our architecture allows for visualizing the component tree, automatic logging of the data flowing through the components, which in turn should allow interactive tracing and debugging of an application.  </li>
<li>A testing library should allow for quick and reliable testing but also pave the way for<br>model-based testing. Testing GUIs involves alleviating a <a href="/scratch/gui_testing/">series of specific issues</a><br>which makes thorough testing an expensive endeavour.</li>
<li>Equally, updating the architecture to handle concurrency in a simpler way can bring significant benefits for those applications which are highly concurrent. </li>
</ol>
<p>Those three areas should be the next focus of our efforts.</p>

  
  
  <div class="footer">
    <a id="follow-button" class="btn" title="Kingly Github" href="https://github.com/brucou/kingly">
      <img class="github" src="/documentation/images/GitHub-Mark-32px.png" alt="github">
    </a>
    <a id="follow-button" class="btn" title="Follow Kingly on Twitter" href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fbrucou.github.io/documentation%2F&amp;ref_src=twsrc%5Etfw&amp;region=follow_link&amp;screen_name=bricoi1&amp;tw_p=followbutton">
      <img class="twitter" src="/documentation/images/icons8-twitter-48.png" alt="twitter">
    </a>
  </div>
</div>

      </div>
      <script src="/documentation/js/smooth-scroll.min.js"></script>
    

    <!-- script for sidebars, version selects etc. -->
    <script src="/documentation/js/css.escape.js"></script>
    <script src="/documentation/js/common.js"></script>
    <!-- mathjax-->
    <script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->


</body>
</html>
