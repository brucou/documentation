<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kingly</title>
  
  
  <link href="/documentation/atom.xml" rel="self"/>
  
  <link href="https://brucou.github.io/"/>
  <updated>2019-05-26T03:40:06.356Z</updated>
  <id>https://brucou.github.io/</id>
  
  <author>
    <name>brucou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Component models for user interfaces implementation - a comparison</title>
    <link href="https://brucou.github.io/2018/01/07/Component%20models%20for%20user%20interfaces%20implementation%20-%20a%20comparison/"/>
    <id>https://brucou.github.io/2018/01/07/Component models for user interfaces implementation - a comparison/</id>
    <published>2018-01-06T23:00:00.000Z</published>
    <updated>2019-05-26T03:40:06.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p> In the previous articles, we have presented our proposed component model for user interfaces<br> implementation, which relies on a cyclejs architecture, and is based on streams and reactive<br> programming techniques.</p><p> We will, in this article, compare our proposed component model to <code>Angular2</code> and <code>React</code> component<br> models<sup><a href="#fn_notCycle" id="reffn_notCycle">notCycle</a></sup> along a few axes. The comparison will help us identify areas for future work :<br>  tooling, testing, and concurrency model.</p><blockquote id="fn_notCycle"><sup>notCycle</sup>. We will not compare it to <code>cyclejs</code> component model as we estimate it does not have a proper one : while it is possible to breakdown a component into smaller components, there is no generic or structured mechanism to glue them together —- it has to be done manually each time. In addition, standard <code>cyclejs</code> conflates the interfaces with the external systems (<code>sources</code>) with the parameterization of components (for instance adding miscellaneous <code>prop$</code> source). It is precisely for that reason that we have come to propose our componentization model.<a href="#reffn_notCycle" title="Jump back to footnote [notCycle] in the text."> &#8617;</a></blockquote><h1 id="Angular2-component-model"><a href="#Angular2-component-model" class="headerlink" title="Angular2 component model"></a>Angular2 component model</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>A component controls a patch of screen called a view. You define a component’s application logic—what it does to support the view—inside a class.  You define a component’s view with its companion template. A template is a form of HTML that tells Angular how to render the component. A template looks like regular HTML, except for a few differences. The class interacts with the view through an API of properties and methods.  To tell Angular that a class is a component, you must attach metadata to the class. In TypeScript, you attach metadata by using a decorator. </p><p>An Angular2 template, in addition to HTML syntax, includes, among other things, the following<br>features:</p><ul><li><a href="https://angular.io/guide/template-syntax#binding-syntax-an-overview" target="_blank" rel="noopener">data binding</a> — includes<br>(property|attribute|class|style) binding, event binding, and two-way binding</li><li><a href="https://angular.io/guide/template-syntax#template-expressions" target="_blank" rel="noopener">template expressions</a> — expressions evaluated in the <a href="https://angular.io/guide/template-syntax#expression-context" target="_blank" rel="noopener">component instance’s context</a>, which produce a value that is assigned to a binding target. Template expressions are written in a language that looks like JavaScript.</li><li><a href="https://angular.io/guide/template-syntax#template-statements" target="_blank" rel="noopener">template statements</a> — evaluated in the <a href="https://angular.io/guide/template-syntax#statement-context" target="_blank" rel="noopener">component instance’s context</a>, responds to an event raised by a binding target such as an element, component, or directive.</li><li>Structural directives (<code>ngFor</code>, <code>ngIf</code>, <code>ngSwitch</code>, etc.) — change the DOM layout by adding and<br>removing DOM elements</li><li>Attribute directives — change the appearance or behavior of an element, component, or another<br>directive (<code>ngStyle</code>, etc.)</li></ul><p>The key methods/decorators for a component’s class are the following :</p><ul><li>inputs admitted by the component</li><li>output produced by the component</li><li>lifecycle methods : <code>constructor</code>, <code>ngOnDestroy</code>, <code>ngOnInit</code></li><li>event handlers</li></ul><p>The key metadata to attach to make a class into a component are : </p><ul><li>the selector which will hold the view</li><li>the template which specifies the view</li><li>the providers which are services (read : functions tackling the concerns not related to displaying the view). Services can be injected</li><li>component directives, which includes other components the declared component will require</li></ul><p>Better than words, here are some sample code from the Angular2 implementation of the project<br>management <a href="https://github.com/PacktPublishing/Mastering-Angular-2-Components" target="_blank" rel="noopener">sample application</a> we dealt with in a <a href="/posts/applying-componentization-to-reactive-systems---sample-application/">previous article</a>.</p><p><strong>Example of component’s class</strong></p><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;  <span class="hljs-comment">// We use the data provider to obtain a data change observer</span>  <span class="hljs-keyword">constructor</span>(@Inject(ProjectService) projectService) &#123;    <span class="hljs-keyword">this</span>.projectService = projectService;    <span class="hljs-keyword">this</span>.projects = [];    <span class="hljs-comment">// Setting up our functional reactive subscription to receive project changes from the database</span>    <span class="hljs-keyword">this</span>.projectsSubscription = projectService.change      <span class="hljs-comment">// We subscribe to the change observer of our service and deal with project changes in the function parameter</span>      .subscribe(<span class="hljs-function">(<span class="hljs-params">projects</span>) =&gt;</span> &#123;        <span class="hljs-keyword">this</span>.projects = projects;        <span class="hljs-comment">// We create new navigation items for our projects</span>        <span class="hljs-keyword">this</span>.projectNavigationItems = <span class="hljs-keyword">this</span>.projects          .filter(<span class="hljs-function">(<span class="hljs-params">project</span>) =&gt;</span> !project.deleted)          .map(<span class="hljs-function">(<span class="hljs-params">project</span>) =&gt;</span> &#123;            <span class="hljs-keyword">return</span> &#123;              <span class="hljs-attr">title</span>: project.title,              <span class="hljs-attr">link</span>: [<span class="hljs-string">'/projects'</span>, project._id]            &#125;;          &#125;);        <span class="hljs-comment">// Uses functional reduce to get a count over open tasks across all projects</span>        <span class="hljs-keyword">this</span>.openTasksCount = <span class="hljs-keyword">this</span>.projects          .reduce(<span class="hljs-function">(<span class="hljs-params">count, project</span>) =&gt;</span> count + project.tasks.filter(<span class="hljs-function">(<span class="hljs-params">task</span>) =&gt;</span> !task.done).length, <span class="hljs-number">0</span>);      &#125;);  &#125;  <span class="hljs-comment">// If this component gets destroyed, we need to remember to clean up the project subscription</span>  ngOnDestroy() &#123;    <span class="hljs-keyword">this</span>.projectsSubscription.unsubscribe();  &#125;&#125;</code></pre><p><strong>Example of component declaration</strong></p><pre><code class="hljs javascript">@Component(&#123;  <span class="hljs-attr">selector</span>: <span class="hljs-string">'ngc-app'</span>,  template,  <span class="hljs-attr">directives</span>: [Project, Navigation, NavigationSection, NavigationItem, ROUTER_DIRECTIVES],  <span class="hljs-attr">providers</span>: [ProjectService, UserService, ActivityService, TagsService]&#125;)</code></pre><p>The interaction between the view defined in the template, and the class is performed through an<br>extensive and complex API, which includes, among other things, binding inputs, outputs,<br>and events.</p><p><strong>Example of template with bindings</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"app"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"app__l-side"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">ngc-navigation</span> [<span class="hljs-attr">openTasksCount</span>]=<span class="hljs-string">"openTaskCount"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">ngc-navigation-section</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"Main"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">ngc-navigation-item</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"Dashboard"</span> [<span class="hljs-attr">link</span>]=<span class="hljs-string">"['/dashboard']"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ngc-navigation-item</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">ngc-navigation-section</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">ngc-navigation-section</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"Projects"</span>                            [<span class="hljs-attr">items</span>]=<span class="hljs-string">"projectNavigationItems"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">ngc-navigation-section</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">ngc-navigation-section</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"Admin"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">ngc-navigation-item</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"Manage Plugins"</span> [<span class="hljs-attr">link</span>]=<span class="hljs-string">"['/plugins']"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ngc-navigation-item</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">ngc-navigation-section</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">ngc-navigation</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"app__l-main"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">router-outlet</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-outlet</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>Note how the template binds together the view, the class and the component, into a cohesive whole,<br>and relate to each other’s entities :</p><ul><li>standard HTML elements describe the view (<code>div</code>, etc.)</li><li><code>ngc-navigation</code> relates to the <code>Navigation</code> component, passed as a directive to the <code>App</code><br>component</li><li><code>openTasksCount</code> from the <code>App</code> class is passed as <em>live</em> input to <code>ngc-navigation</code> (data binding with the <code>[]</code> syntax). This means that whenever <code>openTasksCount</code> will change, the <code>ngc-navigation</code> will adjust to that new value. This is by the way a typical case of parent-child communication via inputs</li></ul><p>The corresponding extract of the code for the <code>Navigation</code> component should illustrate the use of<br> the <code>@Input</code> decorator to bind the parameters passed in the template to properties of the<br> corresponding class :</p> <pre><code class="hljs javascript">@Component(&#123;  <span class="hljs-attr">selector</span>: <span class="hljs-string">'ngc-navigation'</span>,  template,  <span class="hljs-attr">directives</span>: [NavigationSection, UserArea]&#125;)<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Navigation</span> </span>&#123;  @Input() openTasksCount;&#125;</code></pre><p>Because of the coupling between template, class and component, none of those entities can be, a priori, reasoned about individually. As a result, in all what follows when we will refer to a component, unless otherwise specified, we will mean the triple (template, class, @component).</p><p>The ease of reasoning, or understanding, i.e. the readability of an Angular2 application will largely be a function of the component breakdown adopted, and the complexity of the interaction between components, and the complexity of the component definition itself.</p><h2 id="Application-architecture"><a href="#Application-architecture" class="headerlink" title="Application architecture"></a>Application architecture</h2><p>The primary responsibility of a Angular2 component is to display a view described by a template. </p><p>Templates bind events to event handler, which are located in the component’s class. Change<br>propagation and state management is performed by binding between template syntactic elements and<br>the class properties. As such a class has three key responsibilities : state management, event<br>handling, and lifecycle management.</p><p>The component declaration concerns itself with linking the component to the Angular2 framework,<br>so it can be handled and integrated with the rest of the components.</p><p>While being highly prescriptive about syntax (and there is a lot of new syntax), the Angular2<br>component architecture is relatively flexible in terms of the paradigms that it supports. In its<br>simplest expression, events are associated to action handlers, which directly modify local<br>component state, which in turn updates the view. It is however possible to follow functional reactive programming principles to <a href="https://vsavkin.com/managing-state-in-angular-2-applications-caf78d123d02" target="_blank" rel="noopener">some extent</a>, to <a href="https://github.com/ngrx/platform" target="_blank" rel="noopener">a larger extent</a> or simply adopt a redux-like <a href="https://blog.angular-university.io/angular-2-application-architecture-building-applications-using-rxjs-and-functional-reactive-programming-vs-redux/" target="_blank" rel="noopener">one-way data flow</a>.</p><h2 id="Component-interaction"><a href="#Component-interaction" class="headerlink" title="Component interaction"></a>Component interaction</h2><p>The <a href="https://angular.io/guide/component-interaction" target="_blank" rel="noopener">Angular2 documentation</a> lists 4<br>communication methods between components : </p><ul><li><a href="https://angular.io/guide/component-interaction#pass-data-from-parent-to-child-with-input-binding" target="_blank" rel="noopener">Pass data from parent to child with input binding</a></li><li><a href="https://angular.io/guide/component-interaction#parent-listens-for-child-event" target="_blank" rel="noopener">Parent listens for child event</a><ul><li>the implicit pub/sub mechanism associated (linked to the <code>@Output</code> decorator) can also be<br>used to communication between components in different hierarchies, i.e components which are not<br>in a ancestor/child relationship</li></ul></li><li><a href="https://angular.io/guide/component-interaction#parent-and-children-communicate-via-a-service" target="_blank" rel="noopener">Parent and children communicate via a service</a><ul><li>this is equivalent to communication by shared state, except that the service forms a facade<br>which handles the state update logic</li></ul></li><li>Parent owns an instrumentable reference to its child<ul><li><a href="https://angular.io/guide/component-interaction#parent-interacts-with-child-via-local-variable" target="_blank" rel="noopener">interacts with child via local variable</a><ul><li>a reference variable is created at the child level</li></ul></li><li><a href="https://angular.io/guide/component-interaction#parent-calls-an-viewchild" target="_blank" rel="noopener">Parent calls an <code>@ViewChild</code></a><ul><li>this allows the parent to own a reference of its children and directly instrument the<br>children, for instance to modify its state</li></ul></li></ul></li></ul><h2 id="Routing"><a href="#Routing" class="headerlink" title="Routing"></a>Routing</h2><p>The Angular Router enables navigation from one view to the next as users perform application tasks. The router configuration has its own dedicated syntax (directives, decorators, etc.) and <a href="https://angular.io/guide/router#a-crisis-center-with-child-routes" target="_blank" rel="noopener">recommended pattern</a>. Learning to use routing hence requires learning new syntax and building a specific mental model. This leads to a fair amount of syntax to understand but also to produce, and a significant lead time to getting up-to-speed. On the bright side, the router comes already packaged with most of the features one will ever need in a web application.</p><h2 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h2><p>Angular creates, updates, and destroys components automatically as the user moves through the application. The app’s programmer can take action at each moment in this lifecycle through optional lifecycle hooks, like <code>ngOnInit</code>. </p><h2 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h2><p>Isolated unit tests examine an instance of a class all by itself without any dependence on Angular or any injected values. The tester creates a test instance of the class with new, supplying test doubles for the constructor parameters as needed, and then probes the test instance API surface.</p><p>Isolated unit tests should be written for pipes and services.</p><p>Components may be tested in isolation as well. However, isolated unit tests don’t reveal how components interact with Angular. In particular, they can’t reveal how a component class interacts with its own template or with other components.</p><p>Such tests require the Angular testing utilities. The Angular testing utilities include the <code>TestBed</code> class and several helper functions from <code>@angular/core/testing</code>. Writing Angular2 tests again requires learning (and producing) a great deal of new syntax and constructing yet another mental model.</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p><code>Angular2</code> as a framework has a very large scope, and covers the large majority of the needs of<br> the web application programmer. However, this plethora of features comes with the cost of<br> a large incidental complexity. <strong>There are many parts</strong> (<code>Angular2</code> framework architecture,<br> component model, routing, templating, change detection, etc.), <strong>every part is complex</strong> on its<br> own, and then that complexity is <strong>compounded by the inter-relation</strong> or dependencies between the parts. That complexity means a significant time is required to construct the required mental models to understand and produce <code>Angular2</code> code. That complexity also multiplies the possibility of errors in the system’s implementation and may significantly increase debugging time. All those factors negatively impact productivity.</p><p>A good example of complexity generated by inter-related parts is the templating mechanism, <strong>a<br>double-edged sword.</strong> On the one hand, it makes the view contents more readable, specially to people with little coding experience (designers, etc.). On the other hand, the templating language precisely excels at expressing the view content, not at expressing logic and control-flow (loops, branching, etc.). The resulting DSL has a peculiar syntax, is not<br> Turing-complete, which forces to complement it with a general purpose language. That makes two languages to master, the peculiarities of the interface between the two to understand, two tightly coupled files (<code>.html</code> for the view and <code>.ts</code> for the logic) themselves coupled to the router, with what can be significant back-and-forth between the two to fully grasp the view’s behaviour. This impacts negatively both readability and productivity.</p><p>Another source of complexity is the inter-relation between components. For one thing, parent component can directly access and<br>instrument their children, which can make it a nightmare to reason about state in a complex<br>application. Then, depending on the state management strategy adopted, reconstructing the flow of data can be challenging in large component trees. Every component may have its own state, its own bindings and eventing to<br>parent component or any level in the component tree. They can also communicate with the parent via a service (i.e. shared state at the closest common ancestor level). State is then scattered among the application in<br>miscellaneous places, in miscellaneous programming artefacts, with both hidden and explicited<br>dependencies between pieces of state to be aware of, and it may be a arduous process to link all the pieces together. Once again, we are in a situation with <strong>many inter-related parts</strong>, which drives the complexity.<br>This can be mitigated by following a strong discipline about state management (one-way dataflow,<br>single store, reactive programming, etc.), and <strong>documentation</strong>, but this is on the programmer’s onus. A lot of the complexity is inherent to the framework and has be to assumed.</p><p>In summary, Angular2 is without a doubt a <strong>superb piece of technology</strong>. It often addresses<br>efficiently most of the issues a developer must resolve when implementing a user interface. By doing so, it removes a source of incidental complexity through its abstractions (browser quirks, synchronizing state and view,<br>routing, animation, performance, multi-platform targetting, etc.). However it also adds new<br>complexity linked to the number of inter-related concepts/parts which have to be mastered, and the complexity of each of those parts. Taming that complexity will require <strong>considerable discipline</strong> on the side of the developer(s), <strong>good<br>architecting</strong> on the side of the technical leadership, and the same level of <strong>supporting tools</strong><br>(CLI, visualizing component trees, router trees, inspecting component’s properties, etc.) available for the DSL than for the core language. There will be projects where resorting to <code>Angular2</code> does reduce the complexity more than it increases it. Large-scale, enterprise projects might fall in that category —- few user-interface tricks, mostly workflow driven, complexity resides in the domain, more than in the user interface. There will also be projects where <code>Angular2</code> will bring more problems than it<br> will solve.</p><h1 id="React-component-model"><a href="#React-component-model" class="headerlink" title="React component model"></a>React component model</h1><h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><p>Components let you split the UI into independent, reusable pieces, and think about each piece in isolation.<br>Conceptually, components are like JavaScript functions. They accept arbitrary inputs (called<br>“props”), a context (kind of global variable), and return React elements describing what should<br>appear on the screen. Components can be defined either as a function (termed functional components) or as a class.</p><p><strong>functional component</strong></p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Welcome</span>(<span class="hljs-params">props, context</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;&#125;</code></pre><p><strong>class-based component</strong></p><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Welcome</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  render() &#123;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;  &#125;&#125;</code></pre><p>Components can be composed simply by referring to other components in their output. With the help<br> of the <code>JSX</code> DSL, we for instance can write :</p> <pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">return</span> (    &lt;div&gt;      &lt;Welcome name="Sara" /&gt;      &lt;Welcome name="Cahal" /&gt;      &lt;Welcome name="Edite" /&gt;    &lt;/div&gt;  );&#125;``` The `Welcome` component itself could be broken into several other components. This gives rise to a component tree, which JSX allows to express in a readable form (additional benefits are better error and warning messages). The same principle guiding a good component breakdown applies here : loosely-coupled, reusable components, assembled into cohesive parts (cf. [extracting components](https://reactjs.org/docs/components-and-props.html#extracting-components) from the documentation).Generic components, which may admit an unspecified number or type of components, may also be drafted with the special property `props.children` which is akin to Angular2's  `&lt;ng-content&gt;&lt;/ng-content&gt;`, or the slot mechanism (`&lt;slot&gt;&lt;/slot&gt;`) of [web components](https://developers.google.com/web/fundamentals/web-components/shadowdom#slots). This is equivalent to passing the enclosed content of a component as a parameter like any other. An example can be found in the React's [documentation](https://reactjs.org/docs/composition-vs-inheritance.html#containment).The class-based version of components allow to express components which encapsulate state. State management is then handled through life-cycle hooks (`componentDidMount`, `componentWillUnmount`, etc.) and ad-hoc methods possibly calling `setState` to update the local state. This is for  instance the code for a `Clock`  component  updating every second.```javascriptclass Clock extends React.Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123;date: new Date()&#125;;  &#125;  componentDidMount() &#123;    this.timerID = setInterval(      () =&gt; this.tick(),      1000    );  &#125;  componentWillUnmount() &#123;    clearInterval(this.timerID);  &#125;  tick() &#123;    this.setState(&#123;      date: new Date()    &#125;);  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;h1&gt;Hello, world!&lt;/h1&gt;        &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;      &lt;/div&gt;    );  &#125;&#125;``` Note as the `tick` method updates local state, which automatically triggers the (re-)rendering of the clock. There are peculiarities to state update, but they are few : [state update may be asynchronous](https://reactjs.org/docs/state-and-lifecycle.html#state-updates-may-be-asynchronous), and [state updates are merged](https://reactjs.org/docs/state-and-lifecycle.html#state-updates-are-merged). ## Application architectureStateful components, i.e. components which manage their state, can be defined through classes. That class may hold event handlers, and other methods which directly and imperatively update the component's local state, triggering an update of the user interface. The `setState` accept a `prevState` parameter which allows to incrementally update the local state (vs. building the full state each time).Additionally, control flow may be expressed in regular `javascript`, in order to [conditionally display](https://reactjs.org/docs/conditional-rendering.html) components, or iterate over them. `JSX` also provides some specific syntax to that purpose. Displaying lists requires assigning a key to each item, key which must be [unique among siblings](https://reactjs.org/docs/lists-and-keys.html#keys-must-only-be-unique-among-siblings).`JSX`, while close to regular HTML, has some specific syntax ([forms](https://reactjs.org/docs/forms.html), [event binding](https://reactjs.org/docs/handling-events.html)). There are however few specificities, the full syntax can be relatively quickly be acquired, and JSX can be [entirely discarded](https://reactjs.org/docs/react-without-jsx.html) if need be in favor of standard javascript.React strongly encourages [composition over inheritance](https://reactjs.org/docs/composition-vs-inheritance.html), providing mechanisms to compose components which allow to avoid using class inheritance. There a few advanced React concepts ([type checking](https://reactjs.org/docs/typechecking-with-proptypes.html), [Refs](https://reactjs.org/docs/refs-and-the-dom.html), [Performance](https://reactjs.org/docs/optimizing-performance.html), [Fragments](https://reactjs.org/docs/fragments.html), [Portals](https://reactjs.org/docs/portals.html), [Error management](https://reactjs.org/docs/error-boundaries.html)). Each of them has however a small surface, combine simply with the key concepts, resulting in an overall manageable complexity.## Component interactionThe [React documentation](https://reactjs.org/docs/) lists 3 communication methods between components : - [Pass data from parent to child with input binding](https://angular.io/guide/component-interaction#pass-data-from-parent-to-child-with-input-binding)- [Children with parent via ''protected'' shared state and handlers](https://reactjs.org/docs/lifting-state-up.html)  - this is akin to Angular's communication via services. The shared state is lifted up to the   closest common ancestor. The common ancestor passes both the shared state, and a handle to its   children through `props`, handle by which the shared state can be modified (has a closure over   the state, or access to the state via `this`). The passing of handlers reminisces of event   binding. However the mechanism is more private, as only the parent which passes the handler can   be affected by that 'event'.- components communicate between each other via global state  - this may mean using the [`context` feature](https://reactjs.org/docs/context.html) of React,   and is [strongly discouraged](https://medium.com/react-ecosystem/how-to-handle-react-context-a7592dfdcbc).  - another possibility is have a global store at the app level. This is where additional   libraries like `Redux` or `Mobx` come into play.In all cases, React strongly encourages [one-way dataflow](https://reactjs.org/docs/state-and-lifecycle.html#the-data-flows-down) communication between components.## RoutingUnlike `Angular2`, `React` routing does not require a pre-made list of routes to later integrate with the component tree. Routing is expressed by [regular components](https://reacttraining.com/react-router/web/guides/philosophy), and nested routing is just nesting components, like one would nest html's `div`. For instance :```javascriptconst App = () =&gt; (  &lt;BrowserRouter&gt;    &#123;/* here's a div */&#125;    &lt;div&gt;      &#123;/* here's a Route */&#125;      &lt;Route path="/tacos" component=&#123;Tacos&#125;/&gt;    &lt;/div&gt;  &lt;/BrowserRouter&gt;)// when the url matches `/tacos` this component rendersconst Tacos  = (&#123; match &#125;) =&gt; (  // here's a nested div  &lt;div&gt;    &#123;/* here's a nested Route,        match.url helps us make a relative path */&#125;    &lt;Route      path=&#123;match.url + '/carnitas'&#125;      component=&#123;Carnitas&#125;    /&gt;  &lt;/div&gt;)```  This is a very powerful mechanism, which only increases marginally complexity.## LifecycleIn the context of stateful components, classed must have lifecycle methods. This means lifecycle of the local state has to be handled by hand. However, the library automatically handles the lifecycle of the component itself, using the hooks to complement its task. ## TestingUI testing is a complex subject. It encompasses testing :* UI structure : the view should have an expected structure as a function of its state (i.e. $view = f(state)$, where $f$ is a pure function)* UI behaviour : some user action should lead to some system actions (remember the reactive equation $actions = f(state,events)$ where $f$ is a pure function) * UI visual appearance (style, look, etc.) (this can be done by directly comparing pixel by pixel the rendered DOM and the target DOM)I will focus on structure and behaviour testing. React has two main available tools to that purpose : `Jest` and `Enzyme`. Both allow to render a component with or without a DOM, and test its content for the expected structure. A `simulate` method allow to emit events and observe the resulting change in the UI. Mocks and spies can also be used. A summary of the techniques, mostly up-to-date, even if the article is old, can be found [here](http://reactkungfu.com/2015/07/approaches-to-testing-react-components-an-overview/). The testing of actions can be simplified with the use of `redux` and its derivated libraries.## ConclusionReact is significantly less complex than Angular2 for two reasons. First of all, as a library, it takes on less responsibilities than a full-fledged framework like Angular2. Second, there are less parts to handle to build a react application, and each of those parts is relatively easy and quick to understand on its own, with clear and simple interaction with the other parts. For instance, the pseudo-templating technology used (`JSX`) is optional, and embeds nicely into  regular javascript code. All the power of the Turing-complete javascript logic can be used to  render a component while still enjoying the benefits of a HTML-like syntax when necessary. `JSX`  is easy (very few syntactic constructs above HTML) and cohesively located exactly where used,  instead of the file separation imposed by `Angular2`.Furthermore, routing involves just regular components. There is very little new to learn to handle even nested routing. One-way dataflow simplifies state tracking. Similarly to Angular2, there are excellent dev tools which can be built for productivity gains.The most complex aspect is probably testing. `Angular2` requires what seems like some fairly complex set-up in comparison with `React`, but does offer dependency injection. React is silent on the latter. As a result, it is possible that complex applications may be a la fine easier to test with `Angular2`. In fact, adding functionalities to React, means adding parts, and then adding complexity sources. The most common extra parts (`Redux`, `redux-thunk`, `redux-saga`), are in increasing order of complexity, and have to be integrated manually, together with their respective workflow and tooling. Other possible parts (animations, etc.) have to be evaluated. At equal perimeter of features, `React` still compares favorably to  `Angular2`, but the distance is lower. There will be teams and projects for which `Angular2`  will generate a higher value, precisely because it imposes uniform choices, and its set of  technologies is tightly integrated : that is the whole point of a framework.# Our component model## DescriptionOur component model is directly inspired by our functional approach to implement reactive systems, understood as a reactive function linking stream of events to stream of actions, and an interface with external systems to receive events and perform actions. A component in our model is a function with two arguments : `sources` and `settings`. The first argument is the interface to external systems' events and state. The second argument represents the component parametrization concern, and will allow to have generic components which can be specialized or parameterized through those settings. Components in our model compute the relevant system actions to perform, and pass the result of that computation to so-called **drivers**, which interface with the external systems to execute the relevant actions.  The computed actions are passed as an object whose every property  (termed sink) represents a sequence of actions to be handled by the driver for that property.Going back to our functional equations, a component implements a reactive function $f$ such that $actions = f(state, events)$. The  view update action can be shortened to $view = f(state)$, given that the only event which updates the  view is precisely a change of state, whose information is already included in the equation. In   short, we have :$$\begin&#123;cases&#125;   view &amp; = f_v(state) \\\\\   actions &amp; = f_a(state, events)\end&#123;cases&#125; $$Here is an example of component illustrating all the previous points : ```javascriptfunction NavigationItem(sources, settings) &#123;  const &#123; url$ &#125; = sources;  const &#123; project: &#123; title, link &#125; &#125; = settings;  const linkSanitized = link.replace(/\//i, '_');  const events = &#123;    // NOTE : we avoid having to isolate by using the link which MUST be unique over the whole    // application (unicity of a route)    click : sources.DOM.select(`.navigation-section__link.$&#123;linkSanitized&#125;`).events('click')  &#125;;  const state$ = url$    .map(url =&gt; url.indexOf(link) &gt; -1)    .shareReplay(1);  const actions = &#123;    domUpdate : state$.map(isLinkActive =&gt; &#123;      const isLinkActiveClass = isLinkActive ? '.navigation-section__link--active' : '';      return a(        `$&#123;isLinkActiveClass&#125;.navigation-item.navigation-section__link.$&#123;linkSanitized&#125;`,        &#123; attrs: &#123; href: link &#125;, slot: 'navigation-item' &#125;,        title)    &#125;),    router : events.click      .do(preventDefault)      .map(always('/' + link + '/'))  &#125;  return &#123;    [DOM_SINK]: actions.domUpdate,    router: actions.router  &#125;&#125;</code></pre><p>Note the 2 sinks, one for the DOM update driver, one for the router driver. The DOM update driver<br> receives the new DOM, computed only from <code>state$</code>.  The router driver receives the router<br> actions computed only from the events (reduced to <code>click</code> here). Last, note how fixed parameters<br> <code>{ project: { title, link } }</code> are passed to the <code>NavigationItem</code> component through <code>settings</code>.</p><h2 id="Application-architecture-1"><a href="#Application-architecture-1" class="headerlink" title="Application architecture"></a>Application architecture</h2><p>For DOM updates, a <a href="https://github.com/snabbdom/snabbdom" target="_blank" rel="noopener"><code>snabbdom</code></a> virtual DOM syntax is generally used. A virtual node is used for performance reasons. Writing the DOM as a function of state, means that we compute the full DOM<br>every time. Because it would be inefficient to directly display the new DOM, without reusing the<br>already displayed fragments of the current DOM, a virtual node mechanism allows to do a delta<br>between virtual DOM objects, and use that diff to compute and only update the portions of the DOM<br>that needs updating. Note that another syntax in which the dom updates are a function of the<br>state delta (i.e. $ view_{\Delta} = f(state_{\Delta}) $ ) is also possible (that is the model for instance<br>used by <a href="https://ractive.js.org/" target="_blank" rel="noopener"><code>Ractive</code></a>), but has not been investigated for the moment.</p><p>The actual syntax recognized for actions will vary for each driver, and as such should come as<br>part of the documentation for each driver. Drivers perform whatever action on external systems<br>which is part of their specification, and may produce a response, which is passed back into the<br>application via a property of the <code>sources</code> object named the same as the driver’s attributed sink.</p><p>Streams are commonly used when writing the application, allowing to write equations once, with<br>the runtime making sure that they keep in sync, by handling change propagation. This means in<br>particular that there is no need for lifecycle methods, and no need for imperative update of state.</p><p>The reactive functional programming core concepts are built on top of (here <code>rxjs</code>) streams.<br>Events are streams which are <code>shared</code>, behaviours are streams which are <code>shareReplayed(1)</code>.<br>Events modelize… events occuring in the system. Behaviours modelize pieces of state.<br>The adopted granularity of state will depend on the programmer’s design decision and<br>domain at hand. At one extreme, one single behaviour may keep all state in one place. At the other<br> extreme, dividing the application state in pieces may lead to having one behaviour for each piece.</p><p>As such, application architecture is rather simple (streams, events, behaviours, reactive<br>function, drivers are all the parts), though one could argue that the complexity of manipulating<br>state and events in a coordinated way has been transferred to that of understanding and<br>manipulating streams. However, because the stream manipulation has only to be learnt once, for any<br>sufficient large application, we posit that the stream abstraction should lower complexity by<br>eliminating the manual synchronization between events, state and actions. Last, because we write equations, it is<br>easy to reason about our component and application. </p><p>Furthermore, we propose a component model which allows to write an application as the aggregation<br> of smaller, easier to reason about applications. The reactive system under implementation is<br> deconstructed into a component tree, which is assembled by component combinators to give back<br> the target application. </p><p>Component combinators follow a syntax conceptually similar to <code>JSX</code>. For instance :</p><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> SidePanel =  Combine(&#123;&#125;, [Div(<span class="hljs-string">'.app__l-side'</span>), [    Navigation(&#123;&#125;, [      NavigationSection(&#123; <span class="hljs-attr">title</span>: <span class="hljs-string">'Main'</span> &#125;, [        NavigationItem(&#123; <span class="hljs-attr">project</span>: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">'Dashboard'</span>, <span class="hljs-attr">link</span>: <span class="hljs-string">'dashboard'</span> &#125; &#125;, [])      ]),      NavigationSection(&#123; <span class="hljs-attr">title</span>: <span class="hljs-string">'Projects'</span> &#125;, [        InSlot(<span class="hljs-string">'navigation-item'</span>, [ListOfItemsComponent])      ]),      NavigationSection(&#123; <span class="hljs-attr">title</span>: <span class="hljs-string">'Admin'</span> &#125;, [        NavigationItem(&#123; <span class="hljs-attr">project</span>: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">'Manage Plugins'</span>, <span class="hljs-attr">link</span>: <span class="hljs-string">'plugins'</span> &#125; &#125;, [])      ]),    ])  ]]);</code></pre><p>is essentially equivalent to : </p><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> SidePanel =   &lt;Div class='app__l-side'&gt;    &lt;Navigation&gt;            &lt;NavigationSection title='Main'&gt;        &lt;NavigationItem project=&#123; title: 'Dashboard', link: 'dashboard' &#125;/&gt;      &lt;/NavigationSection&gt;      &lt;NavigationSection title='Projects'&gt;        &lt;Slot name='navigation-item'&gt;          ...        &lt;/Slot&gt;      &lt;/NavigationSection&gt;      &lt;NavigationSection title='Admin'&gt;        &lt;NavigationItem project=&#123; title: 'Manage Plugins', link: 'plugins' &#125; /&gt;      &lt;/NavigationSection&gt;    &lt;/Navigation&gt;  &lt;/Div&gt;</code></pre><p>This opens the door to a <code>JSX</code>-like DSL and many other optimizations in the future.</p><h2 id="Component-interaction-1"><a href="#Component-interaction-1" class="headerlink" title="Component interaction"></a>Component interaction</h2><p>There are 4 ways of interaction between components :</p><ul><li>Pass static (i.e. constants) parameterization data from parent to child with <code>settings</code><ul><li>this would be similar to the <code>props</code> passing in <code>React</code></li></ul></li><li>parent can inject state into children<ul><li>this fulfills a similar purpose to the <code>[]</code> binding syntax in <code>Angular2</code></li></ul></li><li>components communicate between each other via global state<ul><li>this means that a in-memory store driver could be used (à la <code>Redux</code>)</li></ul></li><li>components communicate between each other via events<ul><li>a component may send an event to a pub/sub driver, and another component might listen to it.<br>Note that while this pattern is possible, it is not often used in practice</li></ul></li></ul><h2 id="Routing-1"><a href="#Routing-1" class="headerlink" title="Routing"></a>Routing</h2><p>Routing can be realized through the <code>OnRoute</code> combinator and is inserted naturally at the<br>position of the component tree when the routing needs to occur. Routing can also be achieved<br>directly without the combinator though there will necessary be more boilerplate. As a matter of<br>fact, routing is matching a route change event to predefined component(s) actions, and as such<br>remains within the conceptual framework without modification.  </p><h2 id="Lifecycle-1"><a href="#Lifecycle-1" class="headerlink" title="Lifecycle"></a>Lifecycle</h2><p>There is no need for lifecycle management component-wise. Component are just functions. Events<br>and behaviours exists as long as they are necessary, and picked up by the runtime when there is<br>no more reference of them.</p><h2 id="Testing-1"><a href="#Testing-1" class="headerlink" title="Testing"></a>Testing</h2><p>Component can be tested via mocking of the interfaces with the external systems (<code>sources</code> and<br><code>drivers</code>). Given that the component tree is explicit, unit-testing a component involves :</p><ul><li>testing its children components</li><li>testing the parent component</li></ul><p>Testing children components before the parent allow to isolate bugs more quickly, and forces to<br>have a working specification of every component, which is a good practice. Unlike <code>Angular2</code>, the<br> children components are not injected, which means that they cannot be mocked or spyed on. This<br> in turns means that we cannot do white-box testing where we test that the parent component is<br> correctly calling its children component with the right arguments.</p><p> To test the parent, as any component, including the application, the main technique is to mock<br> the interface with the external input systems, i.e. <code>sources</code>, and the event streams which serve<br>  as input to the component under test. This requires that every driver author needs to supply, in<br> addition to the driver code, and documentation, a mock object. The complexity of testing will be<br>  directly linked to the complexity of configuring the necessary set of mock objects. The actions<br>   computed by the reactive function under the test can then be observed and compared with the<br>   expectd results (no need to mock the driver themselves).</p><p>  We have for instance made available a <code>document</code> driver, which is simply injecting the<br>  <code>document</code> object into the <code>sources</code> parameter. The mock version of the driver addresses common<br>   needs (such as simulating an event on a target element). However, a full mock would mean<br>   re-implementing large pans of the interface of <code>document</code> object, which is an error-prone,<br>   time-consuming endeavour.</p><p>   We have designed a <code>runTestScenario</code> helper which facilitates passing inputs, and analyzing<br>   outputs. Here are an example of tests written for a button component :</p><pre><code class="hljs javascript">QUnit.test(<span class="hljs-string">"Good settings : empty settings"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exec_test</span>(<span class="hljs-params">assert</span>) </span>&#123;  <span class="hljs-keyword">const</span> done = assert.async(<span class="hljs-number">2</span>);  <span class="hljs-keyword">const</span> testData = buttonTestSpace.GoodSettings.EmptySettings.caseEmpmtyAndTwoChildren;  <span class="hljs-keyword">const</span> inputs = [    &#123; [EVENT_SOURCE1]: &#123; <span class="hljs-attr">diagram</span>: <span class="hljs-string">'a-b-c|'</span>, <span class="hljs-attr">values</span>: eventSourcesTestValues &#125; &#125;,    &#123; [EVENT_SOURCE2]: &#123; <span class="hljs-attr">diagram</span>: <span class="hljs-string">'-A-B-C|'</span>, <span class="hljs-attr">values</span>: eventSourcesTestValues &#125; &#125;,    &#123;      [<span class="hljs-string">`DOM!<span class="hljs-subst">$&#123;SOME_SELECTOR&#125;</span>@<span class="hljs-subst">$&#123;SOME_DOM_EVENT_NAME&#125;</span>`</span>]: &#123;        <span class="hljs-attr">diagram</span>: <span class="hljs-string">'x-y-z'</span>, <span class="hljs-attr">values</span>: DOMeventsTestValuesSomeSelector      &#125;    &#125;,    &#123;      [<span class="hljs-string">`DOM!<span class="hljs-subst">$&#123;ANOTHER_SELECTOR&#125;</span>@<span class="hljs-subst">$&#123;ANOTHER_DOM_EVENT_NAME&#125;</span>`</span>]: &#123;        <span class="hljs-attr">diagram</span>: <span class="hljs-string">'-x-y-z'</span>, <span class="hljs-attr">values</span>: DOMeventsTestValuesAnotherSelector      &#125;    &#125;,  ];  <span class="hljs-keyword">const</span> ATTRS = <span class="hljs-string">'tabindex="0"'</span>;  <span class="hljs-keyword">const</span> testResults = &#123;    [NON_DOM_SINK]: &#123;      <span class="hljs-attr">outputs</span>: [        <span class="hljs-string">`<span class="hljs-subst">$&#123;SEP&#125;</span> <span class="hljs-subst">$&#123;NON_DOM_SINK&#125;</span>-a`</span>, <span class="hljs-string">`<span class="hljs-subst">$&#123;SEP&#125;</span> <span class="hljs-subst">$&#123;NON_DOM_SINK&#125;</span>-A`</span>,        <span class="hljs-string">`<span class="hljs-subst">$&#123;SEP&#125;</span> <span class="hljs-subst">$&#123;NON_DOM_SINK&#125;</span>-b`</span>, <span class="hljs-string">`<span class="hljs-subst">$&#123;SEP&#125;</span> <span class="hljs-subst">$&#123;NON_DOM_SINK&#125;</span>-B`</span>,        <span class="hljs-string">`<span class="hljs-subst">$&#123;SEP&#125;</span> <span class="hljs-subst">$&#123;NON_DOM_SINK&#125;</span>-c`</span>, <span class="hljs-string">`<span class="hljs-subst">$&#123;SEP&#125;</span> <span class="hljs-subst">$&#123;NON_DOM_SINK&#125;</span>-C`</span>,      ],      <span class="hljs-attr">successMessage</span>: <span class="hljs-string">`sink <span class="hljs-subst">$&#123;NON_DOM_SINK&#125;</span> produces the expected values`</span>,    &#125;,    [DOM_SINK]: &#123;      <span class="hljs-attr">outputs</span>: [        <span class="hljs-string">`&lt;div class=\"ui button\" <span class="hljs-subst">$&#123;ATTRS&#125;</span>&gt;&lt;span&gt;<span class="hljs-subst">$&#123;DOM_SINK&#125;</span> <span class="hljs-subst">$&#123;SEP&#125;</span> a&lt;/span&gt;&lt;span&gt;<span class="hljs-subst">$&#123;DOM_SINK&#125;</span> <span class="hljs-subst">$&#123;SEP&#125;</span> a&lt;/span&gt;&lt;/div&gt;`</span>,        <span class="hljs-string">`&lt;div class=\"ui button\" <span class="hljs-subst">$&#123;ATTRS&#125;</span>&gt;&lt;span&gt;<span class="hljs-subst">$&#123;DOM_SINK&#125;</span> <span class="hljs-subst">$&#123;SEP&#125;</span> b&lt;/span&gt;&lt;span&gt;<span class="hljs-subst">$&#123;DOM_SINK&#125;</span> <span class="hljs-subst">$&#123;SEP&#125;</span> a&lt;/span&gt;&lt;/div&gt;`</span>,        <span class="hljs-string">`&lt;div class=\"ui button\" <span class="hljs-subst">$&#123;ATTRS&#125;</span>&gt;&lt;span&gt;<span class="hljs-subst">$&#123;DOM_SINK&#125;</span> <span class="hljs-subst">$&#123;SEP&#125;</span> b&lt;/span&gt;&lt;span&gt;<span class="hljs-subst">$&#123;DOM_SINK&#125;</span> <span class="hljs-subst">$&#123;SEP&#125;</span> b&lt;/span&gt;&lt;/div&gt;`</span>,        <span class="hljs-string">`&lt;div class=\"ui button\" <span class="hljs-subst">$&#123;ATTRS&#125;</span>&gt;&lt;span&gt;<span class="hljs-subst">$&#123;DOM_SINK&#125;</span> <span class="hljs-subst">$&#123;SEP&#125;</span> c&lt;/span&gt;&lt;span&gt;<span class="hljs-subst">$&#123;DOM_SINK&#125;</span> <span class="hljs-subst">$&#123;SEP&#125;</span> b&lt;/span&gt;&lt;/div&gt;`</span>,        <span class="hljs-string">`&lt;div class=\"ui button\" <span class="hljs-subst">$&#123;ATTRS&#125;</span>&gt;&lt;span&gt;<span class="hljs-subst">$&#123;DOM_SINK&#125;</span> <span class="hljs-subst">$&#123;SEP&#125;</span> c&lt;/span&gt;&lt;span&gt;<span class="hljs-subst">$&#123;DOM_SINK&#125;</span> <span class="hljs-subst">$&#123;SEP&#125;</span> c&lt;/span&gt;&lt;/div&gt;`</span>,      ],      <span class="hljs-attr">transform</span>: convertVNodesToHTML,      <span class="hljs-attr">successMessage</span>: <span class="hljs-string">`sink <span class="hljs-subst">$&#123;DOM_SINK&#125;</span> produces the expected values`</span>,    &#125;,  &#125;;  runTestScenario(inputs, testResults, makeButtonComponent(testData, &#123; <span class="hljs-attr">SEP</span>: SEP &#125;), &#123;    <span class="hljs-attr">tickDuration</span>: <span class="hljs-number">5</span>,    <span class="hljs-attr">waitForFinishDelay</span>: <span class="hljs-number">50</span>,    <span class="hljs-attr">analyzeTestResults</span> : analyzeTestResults(assert, done),    <span class="hljs-attr">mocks</span>: &#123;      <span class="hljs-attr">DOM</span>: makeMockDOMSource    &#125;,    <span class="hljs-attr">sourceFactory</span>: &#123;      [<span class="hljs-string">`DOM!<span class="hljs-subst">$&#123;SOME_SELECTOR&#125;</span>@<span class="hljs-subst">$&#123;SOME_DOM_EVENT_NAME&#125;</span>`</span>]: subjectFactory,      [<span class="hljs-string">`DOM!<span class="hljs-subst">$&#123;SOME_SELECTOR&#125;</span>@<span class="hljs-subst">$&#123;ANOTHER_DOM_EVENT_NAME&#125;</span>`</span>]: subjectFactory,    &#125;,    <span class="hljs-attr">errorHandler</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;      done(err)    &#125;  &#125;)&#125;);</code></pre><p>Note the syntax <code>DOM!${SOME_SELECTOR}@${SOME_DOM_EVENT_NAME}</code> to simulate an event on an element<br>of a given selector. Note also the use of time diagrams to simulate a timed-sequence of inputs.</p><p>While this works, we believe that unit-testing a component is still a pain point, which must be<br>remediated further. Not having to mock the drivers is nice, but having to mock the <code>sources</code><br>generates some unavoidable complexity.</p><p>It is of course possible to test with an automation tool such as <code>selenium</code> which works with a<br>real DOM, just as with <code>Angular2</code> and <code>React</code>.</p><h2 id="Conclusion-1"><a href="#Conclusion-1" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>While <code>React</code> makes the view declarative ($view = f(state)$), our stream-based <code>cyclejs</code><br>architecture makes the whole application declarative ($actions = f (states, events)$). Streams<br>abstract out both asynchrony and change propagation, allowing to reason about a system<br>equationally. While there are architectures (<code>React</code> +<code>Redux</code>/<code>Thunk</code>/<code>Saga</code>; <code>Angular2</code> + <code>ngrx</code><br>and its large ecosystem) which seek to extend declarativeness beyond the view, we however feel pretty comfortable that we do this in a way <strong>fundamentally simpler</strong> than the previously mentioned library/framework.</p><p>We separate the action representation from the actual execution of the action, while both <code>React</code> and <code>Angular2</code> directly performs the actions triggered by user inputs. There are advantages to that which are not fully exploited yet. On the one hand, orchestrating actions (what <a href="https://github.com/redux-saga/redux-saga" target="_blank" rel="noopener"><code>redux-saga</code></a> does) becomes possible with a state machine (we offer the <code>FSM</code> combinator for this), which, while a low-level tool, compensates with its genericity. On the other hand, this simplifies testing by not having to mock action handlers.</p><h1 id="Conclusion-2"><a href="#Conclusion-2" class="headerlink" title="Conclusion"></a>Conclusion</h1><p><code>React</code> and <code>Angular2</code> are library/framework which are either full-featured or come with a<br>extensive list of complements (plugins, libraries, compilers, dev tools, etc.) tackling a lot of<br>the issues that developers face today. They recognize the value of the stream abstraction and<br>are flexible enough to allow for a limited but valuable use of abstractions and architectures<br>based on top of streams.  </p><p>Fully stream-based architectures, in comparison, are still in the infancy of their development and<br>have to be further developed to reach a similar stage of maturity.  In the web user-interface<br>space, <code>cyclejs</code> is such an architecture, on top of which we built our component model. We<br>believe that our component model makes for an easier way to write applications, but above all to<br>understand them, reason about them, and maintain them. The key reason behind our optimism is the<br>inherent declarativeness of our approach based on functional equations.</p><p>Nonetheless, a lot more must be done to make the life of the programmer easier. Among the top<br>priorities is the development of productivity tooling : </p><ol><li>Our architecture allows for visualizing the component tree, automatic logging of the data flowing through the components, which in turn should allow interactive tracing and debugging of an application.  </li><li>A testing library should allow for quick and reliable testing but also pave the way for<br>model-based testing. Testing GUIs involves alleviating a <a href="/scratch/gui_testing/">series of specific issues</a><br>which makes thorough testing an expensive endeavour.</li><li>Equally, updating the architecture to handle concurrency in a simpler way can bring significant benefits for those applications which are highly concurrent. </li></ol><p>Those three areas should be the next focus of our efforts.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h1&gt;&lt;p&gt; In the previous articles, we have presented o
      
    
    </summary>
    
      <category term="programming" scheme="https://brucou.github.io/categories/programming/"/>
    
    
      <category term="functional programming" scheme="https://brucou.github.io/tags/functional-programming/"/>
    
      <category term="reactive programming" scheme="https://brucou.github.io/tags/reactive-programming/"/>
    
      <category term="components" scheme="https://brucou.github.io/tags/components/"/>
    
  </entry>
  
  <entry>
    <title>Applying componentization to reactive systems : sample application</title>
    <link href="https://brucou.github.io/2017/10/16/Applying%20componentization%20to%20reactive%20systems%20-%20sample%20application/"/>
    <id>https://brucou.github.io/2017/10/16/Applying componentization to reactive systems - sample application/</id>
    <published>2017-10-15T22:00:00.000Z</published>
    <updated>2021-02-24T00:58:01.022Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>As discussed in a <a href="/posts/user-interfaces-as-reactive-systems">former post</a>, user interfaces are reactive systems, and can be specified through a reactive function which associate events (originating from the user, or the interfaced systems) to actions to be executed. Expressing events, actions, and local state as streams, and expressing local state update also as an action, we have  : $actions = f(state, events)$, where $f$ is a pure function. In addition to that function, which expresses the logic of the application, interfaces with the relevant systems must be defined. Typically this means interfaces to receive events, and execute actions.</p><p>Our proposed approach is based on cyclejs framework, in which actions are executed through a dedicated interface called <code>driver</code> and events streams are created where and when necessary through streams and streams factories. Those streams factories themselves are passed as parameters to the reactive function. As such the reactive function, in a <code>cyclejs</code> context is not pure. Adjusting for this caveat, our reactive equation still holds.</p><p>We enrich the <code>cyclejs</code> architectural choices, with a <a href="/posts/a-componentization-framework-for-cyclejs">componentization model</a>, which allows to build a larger application from a number of small components with the help of component combinators. A combinator library is provided to cover the most generic needs occurring while building a componentized application, including, but not limited to, sequential composition, data injection, control flow, routing, iteration, change propagation.</p><p>The present document aims at showing how to translate a reactive system specification into an implementation with our proposed componentization model. It is hence :</p><ul><li>part documentation, addressing the question <em>How to leverage the proposed component model to write an application</em></li><li>part showcase, in which the advantages of the componentization approach appear in connection with an iterative software development process</li></ul><p>In the first section, we will quickly describe the application under development. We will then proceed with setting up the structure (shell) in which the application logic will be contained. We will then in subsequent sections, iteratively extend our code to implement more and more of our target application. For each section, we will provide a link to the corresponding source code, contained in a dedicated branch of the demo repository. We will however not develop the whole application here, but the minimum subset necessary for us to reach our documentation and showcasing goals.</p><h1 id="Target-application"><a href="#Target-application" class="headerlink" title="Target application"></a>Target application</h1><p>The target application is a task management application, taken from the <a href="https://github.com/PacktPublishing/Mastering-Angular-2-Components" target="_blank" rel="noopener">Mastering Angular2<br>components</a> book. Users handle projects, projects have tasks, which can be in status finalized or pending. The user can review and update existing tasks, create new tasks, and delete existing ones. Tasks can be filtered by status. The user can add comments to a project which are presented chronologically. A summary of activities can be consulted in a dedicated section. A dashboard provides a summary view of the projects and tasks. Finally, plugins can be administered and integrated into the application to extend its functionality.</p><p>This is an application with a reasonable size, and we will not seek to implement the full functionality previously described, in one go. In the present version of this document, we will focus on a first batch of features, which includes only the project browsing and task management. We will also detail only portions of our implementation, selecting and detailing those portions which illustrates a use of the component model not previously illustrated. This aims at covering as large a percentage possible of the available component combinators, and illustrating as many different techniques as possible.</p><p>Rather than producing a detailed written specification, we will provide the following screenshot, from which a feature list is easy to guess. For supplementary details, we refer the reader to the book.</p><p><img src="/img/screens/main_screen_ang2_example.png" alt="Angular2 project application"></p><p>In addition to this, the following routes are specified :</p><ul><li><code>/dashboard</code>: handles the dashboard functionality</li><li><code>/projects/:projectId</code>: shows the project description, together with a tab bar (<code>Tasks</code>, <code>Comments</code>, <code>Activities</code>)<ul><li><code>/projects/:projectId/tasks</code>: additionally shows the tasks belonging a project with the given <code>projectId</code>, together with a button group to filter tasks, and a input field to enter new tasks</li><li><code>/projects/:projectId/task/:nr</code>: additionally shows a specific task details, with the ability to modify those details </li><li><code>/projects/:projectId/comments</code>: additionally shows the comments logged for a given project </li><li><code>/projects/:projectId/activities</code>: additionally shows the activities logged for a given   project </li></ul></li><li><code>/plugins</code>: handles the plugin functionality</li></ul><h1 id="Step-0-set-up"><a href="#Step-0-set-up" class="headerlink" title="Step 0 : set up"></a>Step 0 : set up</h1><h2 id="Domain-model"><a href="#Domain-model" class="headerlink" title="Domain model"></a>Domain model</h2><p>We will work with a domain model with three entities : projects, tasks, and activities. Data is stored remotely in a firebase repository. Thereafter follows an example of the physical data model (dictated only by our self-imposed constraint to allow for direct comparison with the Angular2 application - there are other ways to design that physical data model):</p><pre><code class="hljs javascript">projects: &#123;    <span class="hljs-attr">_id</span>: <span class="hljs-string">'project-1'</span>,    <span class="hljs-attr">type</span>: <span class="hljs-string">'project'</span>,    <span class="hljs-attr">deleted</span>: <span class="hljs-literal">false</span>,    <span class="hljs-attr">title</span>: <span class="hljs-string">'Your first project'</span>,    <span class="hljs-attr">description</span>: <span class="hljs-string">'This is your first project in the task management system you\'re building within the context of the Angular 2 Components book.'</span>,    <span class="hljs-attr">tasks</span>: [&#123;      <span class="hljs-attr">type</span>: <span class="hljs-string">'task'</span>,      <span class="hljs-attr">nr</span>: <span class="hljs-number">1</span>,      <span class="hljs-attr">position</span>: <span class="hljs-number">0</span>,      <span class="hljs-attr">title</span>: <span class="hljs-string">'Task 1'</span>,      <span class="hljs-attr">done</span>: <span class="hljs-literal">null</span>,      <span class="hljs-attr">created</span>: +Moment(now),      <span class="hljs-attr">efforts</span>: &#123;        <span class="hljs-attr">estimated</span>: <span class="hljs-number">86400000</span>,        <span class="hljs-attr">effective</span>: <span class="hljs-number">0</span>      &#125;    &#125;]  &#125;activities: [    &#123;    <span class="hljs-attr">type</span>: <span class="hljs-string">'activity'</span>,    <span class="hljs-attr">user</span>: &#123;      <span class="hljs-attr">name</span>: <span class="hljs-string">'You'</span>,      <span class="hljs-attr">pictureDataUri</span>: <span class="hljs-string">'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAxOS4yLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCINCgkgdmlld0JveD0iMCAwIDMxMS41IDMxMS41IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCAzMTEuNSAzMTEuNTsiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4NCgkuc3Qwe2ZpbGw6IzMzMzMzMzt9DQo8L3N0eWxlPg0KPGc+DQoJPGc+DQoJCTxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik0xNTUuOCwwQzY5LjcsMCwwLDY5LjcsMCwxNTUuOGMwLDM3LjUsMTMuMyw3MS45LDM1LjMsOTguOGMzLjQtMjcuMywzMC42LTUwLjMsNjguOC02MS4yDQoJCQljMTMuOSwxMywzMiwyMC45LDUxLjcsMjAuOWMxOS4yLDAsMzYuOS03LjUsNTAuNy0xOS45YzM4LjUsMTEuOSw2NS4xLDM2LjMsNjYsNjQuNmMyNC4zLTI3LjUsMzkuMS02My42LDM5LjEtMTAzLjENCgkJCUMzMTEuNSw2OS43LDI0MS44LDAsMTU1LjgsMHogTTE1NS44LDE5NS43Yy05LjksMC0xOS4zLTIuNy0yNy42LTcuNWMtMjAuMS0xMS40LTMzLjktMzQuOC0zMy45LTYxLjdjMC0zOC4xLDI3LjYtNjkuMiw2MS41LTY5LjINCgkJCWMzMy45LDAsNjEuNSwzMSw2MS41LDY5LjJjMCwyNy40LTE0LjIsNTEtMzQuOCw2Mi4yQzE3NC40LDE5My4yLDE2NS4zLDE5NS43LDE1NS44LDE5NS43eiIvPg0KCTwvZz4NCjwvZz4NCjwvc3ZnPg0K'</span>    &#125;,    <span class="hljs-attr">time</span>: +Moment(now),    <span class="hljs-attr">subject</span>: <span class="hljs-string">'project-1'</span>,    <span class="hljs-attr">category</span>: <span class="hljs-string">'tasks'</span>,    <span class="hljs-attr">title</span>: <span class="hljs-string">'A task was updated'</span>,    <span class="hljs-attr">message</span>: <span class="hljs-string">'The task \'New task created\' was updated on #project-1.'</span>,    <span class="hljs-attr">_id</span>: <span class="hljs-string">'ECEF8127-C237-9612-924B-2A087D6FACA4'</span>  &#125;,  ]<span class="hljs-string">``</span><span class="hljs-string">` ## Interfaced systems' driversActions that are undertaken as a response to events are : domain data update, DOM update, route change, and of course updating local state (persisted and non persisted). As per events to be handled by the system, we have : user events (i.e. DOM events), local state update notification, route change notification.This leads to the following drivers:- write drivers: DOM driver, router driver, domain update driver, local state update driver - read drivers: DOM driver, router driver, domain query driver, local state query driverWe will use:- router driver: for read and write, we use the same [history driver](https://github.com/cyclejs/cyclejs/tree/master/history) from `</span>cycle<span class="hljs-string">`- DOM write driver: standard snabbdom default DOM `</span>cycle<span class="hljs-string">` driver- DOM read driver: document driver which injects the `</span><span class="hljs-built_in">document</span><span class="hljs-string">` dependency to read from the DOM- domain update and query drivers: we use a domain [Query](/projects/component-combinators/querydriver) driver and domain [Action](/projects/component-combinators/actiondriver) driver, where entities and the methods applicable to them are defined - local state drivers: we use a in-memory store to query and update data in the local domainThis leads us to the following set up code:`</span><span class="hljs-string">``</span>javascript    <span class="hljs-keyword">const</span> &#123; sources, sinks &#125; = run(App, &#123;      [DOM_SINK]: filterNull(makeDOMDriver(<span class="hljs-string">'#app'</span>, &#123;        <span class="hljs-attr">transposition</span>: <span class="hljs-literal">false</span>,        <span class="hljs-attr">modules</span>: defaultModules      &#125;)),      <span class="hljs-attr">document</span>: documentDriver,      <span class="hljs-attr">domainQuery</span>: makeDomainQueryDriver(repository, domainObjectsQueryMap),      <span class="hljs-attr">domainAction$</span>: makeDomainActionDriver(repository, domainActionsConfig),      <span class="hljs-attr">storeAccess</span>: makeDomainQueryDriver(inMemoryStore, inMemoryStoreQueryMap),      <span class="hljs-attr">storeUpdate$</span>: makeDomainActionDriver(inMemoryStore, inMemoryStoreActionsConfig),      <span class="hljs-attr">router</span>: makeHistoryDriver(createHistory(), &#123; <span class="hljs-attr">capture</span>: <span class="hljs-literal">true</span> &#125;),    &#125;);</code></pre><p>For the full code and running demo, see <a href="https://github.com/brucou/component-combinators/tree/project-management-app-step-0/examples/AllInDemo" target="_blank" rel="noopener">here</a>. </p><h1 id="Step-1-SidePanel-navigation-and-MainPanel"><a href="#Step-1-SidePanel-navigation-and-MainPanel" class="headerlink" title="Step 1 : SidePanel (navigation) and MainPanel"></a>Step 1 : SidePanel (navigation) and MainPanel</h1><p>We divide the application in two independent components, one handling the side navigation (<code>SidePanel</code>) and the other one handling functionalities depending on the current route (<code>MainPanel</code>). </p><p>Our starting code for the <code>App</code> is then:</p><pre><code class="hljs javascript">App = Combine(&#123;&#125;, [Div(<span class="hljs-string">'.app'</span>), [                    SidePanel,                    MainPanel                  ]])</code></pre><p>This deserves a few words of explanation. <code>Combine</code> is a combinator which takes some components (let’s call them children components), and returns a combined component. That combined component will pass its sources and settings (here <code>{}</code>) to all children components to compute their sinks, merge<sup><a href="#fn_merge" id="reffn_merge">merge</a></sup> the resulting non-DOM sinks from the children components, and combine the DOM sinks <a href="/projects/component-combinators/m-component---merge-default-functions/#slotted-dom-merge">à la web components</a>, by dispatching children DOM content into its respective slots (the container component holds the slot definition — here <code>Div(&#39;.app&#39;)</code> does not define any slot). The full details of how <code>Combine</code>‘s merge mechanism works can be found in the <a href="/projects/component-combinators/m-component---merge-default-functions/">corresponding documentation</a>. Note that it is important to understand how <code>Combine</code> merges children sinks, as most of the combinators in the library, merge sinks in the same way.</p><blockquote id="fn_merge"><sup>merge</sup>. Simple merge is used for non-DOM sinks (as in <code>Rx.Observable.merge</code>). Another example of such simple merge can be found in the <a href="https://github.com/cyclejs-community/cyclejs-utils" target="_blank" rel="noopener"><code>cyclejs-utils</code></a> utility library for cycle.<a href="#reffn_merge" title="Jump back to footnote [merge] in the text."> &#8617;</a></blockquote><p>We are however going to do two things : inject pieces of state that will be used by both components, and massage the route input arriving through the router driver in a convenient form (basically removing a leading <code>/</code> if any). This can be done at any relevant level. However, as those sources of events and pieces of state will be used by the whole application, it is more DRY to inject them at the top level, so that all downstream components inherit them unless otherwise configured. For the same reason, we will configure the settings of the router driver once for all, and declare the list of sinks that the application handles at this level. <code>sinkNames</code> is mandatory for several components combinators to filter the sinks returned from children components, so we put it at the top level for the same DRY reasons. </p><p>The <code>settings</code> and <code>sources</code> inheritance mechanism is described in the documentation for the <code>m</code> combinator and the <a href="/projects/component-combinators/injectsourcesandsettings/"><code>InjectSourcesAndSettings</code> combinator</a>. </p><p>The corresponding code includes:</p><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> App = InjectSourcesAndSettings(&#123;    <span class="hljs-attr">sourceFactory</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sources, settings</span>) </span>&#123;      <span class="hljs-comment">// NOTE : we need the current route which is a behaviour</span>      <span class="hljs-keyword">const</span> &#123; router, domainQuery &#125; = sources;      <span class="hljs-keyword">const</span> currentRouteBehaviour = router        .map(<span class="hljs-function"><span class="hljs-params">location</span> =&gt;</span> &#123;          <span class="hljs-keyword">const</span> route = location.pathname;          <span class="hljs-keyword">return</span> (route &amp;&amp; route[<span class="hljs-number">0</span>] === <span class="hljs-string">'/'</span>) ? route.substring(<span class="hljs-number">1</span>) : route        &#125;)        <span class="hljs-comment">// starts with home route</span>        .startWith(<span class="hljs-string">''</span>)        .shareReplay(<span class="hljs-number">1</span>);      <span class="hljs-comment">// NOTE : we need the route change event</span>      <span class="hljs-comment">// Now it was important to do this in that order, because we want currentRouteBehaviour to</span>      <span class="hljs-comment">// be subscribed before (no route change before having a current route)</span>      <span class="hljs-comment">// A former implementation url$ = incomingRouteEvents$.shareReplay(1) failed as url$ was not</span>      <span class="hljs-comment">// subscribed till after the route had changed, and by then the new route value was already</span>      <span class="hljs-comment">// emitted, so url$ would not emit anything... One has to be very careful dealing with</span>      <span class="hljs-comment">// streams and ordering</span>      <span class="hljs-keyword">const</span> incomingRouteEvents$ = currentRouteBehaviour.share();      <span class="hljs-keyword">const</span> projects$ = domainQuery.getCurrent(PROJECTS);      <span class="hljs-keyword">const</span> user$ = domainQuery.getCurrent(USER);      <span class="hljs-keyword">return</span> &#123;        <span class="hljs-comment">// router</span>        url$: currentRouteBehaviour,        [ROUTE_SOURCE]: incomingRouteEvents$,        <span class="hljs-comment">// NOTE : domain driver always send behaviour observables (i.e. sharedReplayed already)</span>        user$,        <span class="hljs-comment">// NOTE : `values` to get the actual array because firebase wraps it around indices</span>        projects$: projects$.map(values),        <span class="hljs-attr">projectsFb$</span>: projects$      &#125;    &#125;,    <span class="hljs-attr">settings</span>: &#123;      <span class="hljs-attr">sinkNames</span>: [<span class="hljs-string">'domainAction$'</span>, <span class="hljs-string">'storeUpdate$'</span>, DOM_SINK, <span class="hljs-string">'router'</span>, <span class="hljs-string">'focus'</span>],      <span class="hljs-attr">routeSource</span>: ROUTE_SOURCE    &#125;  &#125;, [Div(<span class="hljs-string">'.app'</span>), [    SidePanel,    MainPanel  ]]);</code></pre><p><strong>Pay attention to</strong>:</p><ul><li>the querying for domain entities related to the projects and the user through the query driver (for instance <code>domainQuery.getCurrent(PROJECTS)</code>)</li><li>the use of <code>Div(&#39;.app&#39;)</code> as a container for the list of components (main and side panels). Full explanation of the feature can be found at the <a href="/projects/component-combinators/m-component---merge-default-functions/#regular-dom-merge">corresponding documentation page</a> (the container here acts as parent component). In short, all DOM trees returned by the enclosed components will be inserted within the DOM tree of the container. </li><li>the distinction between the route change event, and the route state which is a behaviour<sup><a href="#fn_behaviour" id="reffn_behaviour">behaviour</a></sup>. The general, and very important rule, is to <strong>systematically</strong> decide whether a reactive entity of interest is modelized better by an event or a behaviour, and to apply the corresponding marker (<code>share()</code> for events, <code>shareReplay(1)</code> for behaviours)<sup><a href="#fn_marker" id="reffn_marker">marker</a></sup>. Failing to do this is the origin of a <strong>large portion of bugs</strong> encountered when manipulating streams.</li></ul><blockquote id="fn_behaviour"><sup>behaviour</sup>. The reason why we need both the route change event and the route state is that sometimes we want to get the current route without reacting to a route change, and the best way to achieve this is to use <code>shareReplay(1)</code> in connection with <code>sample</code> or <code>withLatestFrom</code>. <a href="#reffn_behaviour" title="Jump back to footnote [behaviour] in the text."> &#8617;</a></blockquote><blockquote id="fn_marker"><sup>marker</sup>. A good way to enforce this is to build on top of the stream library constructors for events and behaviours, and enforce their usage, effectively prohibiting direct manipulation of the underlying streams. We do not follow this option however, to avoid adding extra syntax. We might reconsider later on, based on feedback.<a href="#reffn_marker" title="Jump back to footnote [marker] in the text."> &#8617;</a></blockquote><p>For the full code and running demo, see <a href="https://github.com/brucou/component-combinators/tree/project-management-app-step-1/examples/AllInDemo" target="_blank" rel="noopener">here</a>. </p><p>This example allows us to illustrate an important componentization tip. </p><h2 id="Tip-What-makes-a-good-breakdown"><a href="#Tip-What-makes-a-good-breakdown" class="headerlink" title="Tip : What makes a good breakdown"></a><strong>Tip</strong> : What makes a good breakdown</h2><p>What makes this breakdown a good one? Independence or loose coupling is the key here:</p><ul><li><code>MainPanel</code> can be implemented fairly independently from <code>SidePanel</code></li><li>the only reason for change of <code>SidePanel</code> that would affect <code>MainPanel</code> is a change in the<br>route associated to the projects<sup><a href="#fn_routechange" id="reffn_routechange">routechange</a></sup></li><li>both components share no common events or actions or logic. We took our initial reactive system, split it in two, smaller, largely independent subsystems, whose complexity is strictly lower than the original system, and easier to write</li></ul><blockquote id="fn_routechange"><sup>routechange</sup>. The corresponding change could be anticipated by designing the main panel to allow for parameterization of these routes. This would ensure that a change in <code>SidePanel</code> does not entail a change in <code>MainPanel</code> implementation, but rather a change in parameterization (we have decided not to refactor our sample application in that direction though, to not distract the learner with implementation details)<a href="#reffn_routechange" title="Jump back to footnote [routechange] in the text."> &#8617;</a></blockquote><p>More generally, it is desirable to build a complex system by assembling, in a cohesive way, loosely coupled components, so that the cost of redesigning each of such adoptable components (or replacing by a better component) can be minimized.</p><h1 id="Step-2-SidePanel"><a href="#Step-2-SidePanel" class="headerlink" title="Step 2 : SidePanel"></a>Step 2 : SidePanel</h1><p>Let’s implement our <code>SidePanel</code> component. Here are the specifications we can extract from the overall application’s specifications :</p><div class="table-container"><table><thead><tr><th>Events</th><th>Actions</th></tr></thead><tbody><tr><td>INIT</td><td>DOM : display welcome message and task summary</td></tr><tr><td></td><td>DOM : display 3 sections with  possibly subsections</td></tr><tr><td>click on subsections</td><td>navigate to the corresponding route</td></tr></tbody></table></div><p>We define the routes to be navigated to as per specification:</p><ul><li><code>/projects/:projectId</code></li><li><code>/dashboard</code></li><li><code>/plugins</code></li></ul><p>To compute the DOM view (in particular the task summary and the projects section), we will need a local copy of the remotely persisted following domain entities:</p><ul><li><code>projects</code></li><li><code>user</code></li></ul><p>As explained in the previous step, we have already injected those sources at the top level of the application. This means that those sources will be available for every component under <code>sources.user$</code>, and <code>sources.projects$</code>. We will then seek to write <code>SidePanel</code> as:</p><pre><code class="hljs javascript">SidePanel =  Combine(&#123;&#125;, [Div(<span class="hljs-string">'.app__l-side'</span>), [    Navigation(&#123;&#125;, [      NavigationSection(&#123; <span class="hljs-attr">title</span>: <span class="hljs-string">'Main'</span> &#125;, [        NavigationItem(&#123; <span class="hljs-attr">project</span>: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">'Dashboard'</span>, <span class="hljs-attr">link</span>: <span class="hljs-string">'dashboard'</span> &#125; &#125;, [])      ]),      NavigationSection(&#123; <span class="hljs-attr">title</span>: <span class="hljs-string">'Projects'</span> &#125;, [        InSlot(<span class="hljs-string">'navigation-item'</span>, [ListOfItemsComponent])      ]),      NavigationSection(&#123; <span class="hljs-attr">title</span>: <span class="hljs-string">'Admin'</span> &#125;, [        NavigationItem(&#123; <span class="hljs-attr">project</span>: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">'Manage Plugins'</span>, <span class="hljs-attr">link</span>: <span class="hljs-string">'plugins'</span> &#125; &#125;, [])      ]),    ])  ]]);</code></pre><p>where:</p><ul><li><code>Navigation</code> is a ad-hoc component combinator which:<ul><li>accepts children components as an array of components</li><li>wraps all <code>navigation-section</code> slot content from its children components into a <code>nav</code> tag</li><li>passes up unmodified all non-DOM actions (carried by the non-DOM sinks)</li><li>adds some style specific to its navigation concern</li></ul></li><li><code>NavigationSection</code> is a component combinator which:<ul><li>can (must) be parametrized by a <code>title</code> property</li><li>accepts children components as an array of components</li><li>wraps all <code>navigation-item</code> slot content from its children components into a list item (<code>li</code>)</li><li>passes up unmodified all non-DOM actions from its children component (carried by the non-DOM sinks)</li><li>adds some style specific to its navigation concern</li></ul></li><li><code>NavigationItem</code> is a component combinator which:<ul><li>can (must) be parametrized by the <code>title</code> and <code>link</code> properties</li><li>does not accept children components</li><li>displays the title, and a click on that title triggers a routing action passed through the router sink</li><li>emphasizes the current project selection as determined by the route <code>/projects/:projectId</code></li></ul></li><li><code>ListOfItemsComponent</code> is a component which, from <code>projects</code>:<pre><code>- get the current list of projects,- computes a title (project name) and a link (`/project/projectId`),- and for each project in that list, accumulates it in the shape of a `NavigationItem` parameterized with the computed title and link</code></pre></li></ul><p>Let’s go in detail about the implementation, and by doing so learn about the slot mechanism, how to write ad-hoc combinators, and components which displays a list of items.</p><h2 id="Slots-and-container-components"><a href="#Slots-and-container-components" class="headerlink" title="Slots and container components"></a>Slots and container components</h2><p>Combinators accept either a list of components (<code>Array&lt;Component&gt;</code>), or a container and a list of components (<code>[ContainerComponent, Array&lt;ChildrenComponent&gt;]</code>). The container component is used to apply some processing to the children components’ sinks. Unless otherwise specified, the default processing is to merge all non-DOM actions from the children components’ sinks, and to merge DOM sinks from the children components’ sinks following a slot mechanism à la web components. </p><p>The container component may define a slot or location, where children DOM sinks will be inserted. The container component hence provides a template, and the children DOM sinks provide the content filling that template. For more details of the slot mechanism, see the <a href="/projects/component-combinators/m-component---merge-default-functions/#slotted-dom-merge">documentation</a>. A simple way to set a slot for the DOM content for children components is to use the <a href="/projects/components-combinators/inslot"><code>InSlot</code></a> combinator.</p><p>For our <code>Navigation</code> combinator, we want to put the DOM sinks corresponding to the navigation sections after displaying the welcome message, and within a styling <code>div</code>.</p><p>We define first the container component, which displays the welcome message and task count(termed <code>TaskSummary</code> here), and declares the slot for the navigation sections:</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">NavigationContainerComponent</span>(<span class="hljs-params">sources, settings</span>) </span>&#123;  <span class="hljs-keyword">const</span> &#123; user$, projects$ &#125; = sources;  <span class="hljs-comment">// combineLatest allows to construct a behaviour from other behaviours</span>  <span class="hljs-keyword">const</span> state$ = $.combineLatest(user$, projects$, (user, projects) =&gt; (&#123; user, projects &#125;))  <span class="hljs-keyword">return</span> &#123;    [DOM_SINK]: state$.map(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> &#123;      <span class="hljs-keyword">return</span> div(<span class="hljs-string">'.navigation'</span>, [        renderTasksSummary(state),        nav(&#123; <span class="hljs-attr">slot</span>: <span class="hljs-string">'navigation-section'</span> &#125;, [])      ])    &#125;)  &#125;&#125;</code></pre><h2 id="Navigation-combinator"><a href="#Navigation-combinator" class="headerlink" title="Navigation combinator"></a>Navigation combinator</h2><p>After that, we are ready to define the <code>Navigation</code> combinator:</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Navigation</span>(<span class="hljs-params">navigationSettings, componentArray</span>)</span>&#123;  <span class="hljs-keyword">return</span> Combine(navigationSettings, [NavigationContainerComponent, componentArray])&#125;</code></pre><h2 id="NavigationSection-combinator"><a href="#NavigationSection-combinator" class="headerlink" title="NavigationSection combinator"></a>NavigationSection combinator</h2><p>In the same way, we can write the <code>NavigationSection</code> as:</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">NavigationSectionContainerComponent</span>(<span class="hljs-params">sources, settings</span>) </span>&#123;  <span class="hljs-keyword">const</span> &#123; title &#125; = settings;  <span class="hljs-keyword">return</span> &#123;    [DOM_SINK]: $.<span class="hljs-keyword">of</span>(      div(<span class="hljs-string">'.navigation-section'</span>, &#123; <span class="hljs-attr">slot</span>: <span class="hljs-string">'navigation-section'</span> &#125;, [        h2(<span class="hljs-string">'.navigation-section__title'</span>, title),        ul(<span class="hljs-string">'.navigation-section__list'</span>, &#123; <span class="hljs-attr">slot</span>: <span class="hljs-string">'navigation-item'</span> &#125;, [])      ])    )  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">NavigationSection</span>(<span class="hljs-params">navigationSectionSettings, componentArray</span>)</span>&#123;  <span class="hljs-keyword">return</span> Combine(navigationSectionSettings, [NavigationSectionContainerComponent, componentArray])&#125;</code></pre><p>Pay attention to how:</p><ul><li>the <code>div</code> vNode combinator has been extended with a slot module. That slot module marks the corresponding vTree with the name of the slot it belongs to. Note also how we set the slot for the <code>NavigationItem</code> components (reminder : <code>NavigationItem</code> are the expected children components for <code>NavigationSection</code>)</li><li>For the <code>navigation-section</code> slot, content is provided. For the <code>navigation-item</code>, content is not provided, as it will be filled in by children components.</li><li><code>navigation-section</code> slot is at the top level of the <code>vNode</code> tree for the <code>NavigationSectionContainerComponent</code>. Similarly, <code>NavigationItem</code> components will also have to have their slot set at top level, because slot merging only looks at the children’s DOM top vNode for slots.</li></ul><h2 id="ListOfItemsComponent-component"><a href="#ListOfItemsComponent-component" class="headerlink" title="ListOfItemsComponent component"></a>ListOfItemsComponent component</h2><p>Last, let’s see how to write a component which displays a list of items. We have the <a href="/projects/component-combinators/listof"><code>ListOf</code></a> combinator which does just that, but we have to call it with the right inputs. To do so, we will first inject the relevant piece of state (the list to project titles to be displayed, and the links to navigate to) with <code>InjectSourcesAndSettings</code>. We also want the side panel updated whenever the project titles change in the source of  truth (remote repository). The <a href="/projects/component-combinators/foreach"><code>ForEach</code></a> allows to activate a component tree whenever the value of a behaviour changes, or an event is emitted ; and will cover our requirements nicely. This leads to the following code:</p> <pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getProjectNavigationItems$</span>(<span class="hljs-params">sources, settings</span>) </span>&#123;   <span class="hljs-keyword">return</span> sources.projects$     .map(filter(<span class="hljs-function"><span class="hljs-params">project</span> =&gt;</span> !project.deleted))     .map(map(<span class="hljs-function"><span class="hljs-params">project</span> =&gt;</span> (&#123;       <span class="hljs-attr">title</span>: project.title,       <span class="hljs-attr">link</span>: [<span class="hljs-string">'projects'</span>, project._id].join(<span class="hljs-string">'/'</span>)     &#125;)))     .distinctUntilChanged()     <span class="hljs-comment">// NOTE : this is a behaviour</span>     .shareReplay(<span class="hljs-number">1</span>)     ;&#125;<span class="hljs-keyword">const</span> ListOfItemsComponent =  InjectSources(&#123; <span class="hljs-attr">projectNavigationItems$</span>: getProjectNavigationItems$ &#125;, [    ForEach(&#123; <span class="hljs-attr">from</span>: <span class="hljs-string">'projectNavigationItems$'</span>, <span class="hljs-attr">as</span>: <span class="hljs-string">'projectList'</span> &#125;, [      ListOf(&#123; <span class="hljs-attr">list</span>: <span class="hljs-string">'projectList'</span>, <span class="hljs-attr">as</span>: <span class="hljs-string">'project'</span> &#125;, [        EmptyComponent,        NavigationItem      ])    ])  ]);<span class="hljs-string">``</span><span class="hljs-string">`   For each new value of `</span>projectNavigationItems$<span class="hljs-string">`, the setting property `</span>projectList<span class="hljs-string">` will be updated to that value, and a list of `</span>NavigationItem<span class="hljs-string">` will be activated. Each of the `</span>NavigationItem<span class="hljs-string">` will receive a `</span>project<span class="hljs-string">` setting property which holds the value of one element of the `</span>projectList<span class="hljs-string">` array, together with the index of that particular element. For more information, see the corresponding documentation of both operators. For the full code and running demo, see [here](https://github.com/brucou/component-combinators/tree/project-management-app-step-2/examples/AllInDemo). # Step 3 : Main panelAs per specifications, the main panel is url-driven. This gives us the following breakdown:`</span><span class="hljs-string">``</span>javascript<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> MainPanel =  Combine(&#123;&#125;, [Div(<span class="hljs-string">`.app__l-main`</span>), [    OnRoute(&#123; <span class="hljs-attr">route</span>: <span class="hljs-string">'dashboard'</span> &#125;, [ProjectsDashboard]),    OnRoute(&#123; <span class="hljs-attr">route</span>: <span class="hljs-string">'projects/:projectId'</span> &#125;, [Project]),    OnRoute(&#123; <span class="hljs-attr">route</span>: <span class="hljs-string">'plugins'</span> &#125;, [ManagePlugins]),  ]]);</code></pre><p>where:</p><ul><li><code>ProjectsDashboard</code> handles the dashboard functionality</li><li><code>ManagePlugins</code> handles the plugin functionality</li><li><code>Project</code> handles the display of information about the projects and the tab bar (<code>Task</code>, <code>Comment</code>, <code>Activities</code>)</li></ul><p>As it is immediately visible from the example, configuring components to be activated on a given route is pretty straight forward. Not immediately visible here, in the case of a route with parameter (<code>projects/:projectId</code>), the parameters (<code>projectId</code>) will be passed to downstream components through <code>settings</code>. For more details on the <code>OnRoute</code> combinator, see the <a href="/projects/component-combinators/router/">documentation</a>. </p><p>We will not go into detail about all three components, but rather focus on detailing the <code>Project</code> component.</p><h2 id="Project-component"><a href="#Project-component" class="headerlink" title="Project component"></a>Project component</h2><p>The project component has the following specifications:</p><div class="table-container"><table><thead><tr><th>Events</th><th>Actions</th></tr></thead><tbody><tr><td>INIT</td><td>DOM : display project header and tab bar with no tab selected</td></tr><tr><td>route change to <code>tasks</code></td><td>DOM : display project task list</td></tr><tr><td>route change to <code>task/:nr</code></td><td>DOM : display task detail for task <code>nr</code></td></tr><tr><td>route change to <code>comments</code></td><td>DOM : display project’s comments</td></tr><tr><td>route change to <code>activities</code></td><td>DOM : display project’s activities</td></tr></tbody></table></div><p>The relevant piece of state here (reminder : the route here is <code>projects/:projectId</code>) is information about the specific project pointed at by the route. This is the object from which we will get the project’s comments, activities, etc.</p><p>The state we need is retrieved as follows  </p><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">projectsStateFactory</span>(<span class="hljs-params">sources, settings</span>) </span>&#123;  <span class="hljs-keyword">const</span> &#123; [ROUTE_PARAMS]: &#123; projectId &#125; &#125; = settings;  <span class="hljs-keyword">return</span> sources.projectsFb$    .map(<span class="hljs-function"><span class="hljs-params">projectsFb</span> =&gt;</span> &#123;      <span class="hljs-keyword">const</span> fbKeys = keys(projectsFb);      <span class="hljs-keyword">const</span> _values = values(projectsFb);      <span class="hljs-keyword">const</span> index = _values.findIndex(<span class="hljs-function"><span class="hljs-params">project</span> =&gt;</span> project._id === projectId);      <span class="hljs-keyword">const</span> fbIndex = fbKeys[index];      <span class="hljs-keyword">const</span> project = _values[index];      <span class="hljs-keyword">return</span> &#123;        fbIndex,        project      &#125;    &#125;)    .shareReplay(<span class="hljs-number">1</span>)&#125;</code></pre><p>Not how <code>projectId</code> from the route is passed through <code>settings</code>. Then <code>Project</code> can be written as:</p><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Project =  InjectSources(&#123; <span class="hljs-attr">projectFb$</span>: projectsStateFactory &#125;, [Div(<span class="hljs-string">'.project'</span>), [    ProjectHeader,    Combine(&#123; tabItems &#125;, [TabContainer, [      OnRoute(&#123; <span class="hljs-attr">route</span>: <span class="hljs-string">'tasks'</span> &#125;, [ProjectTaskList]),      OnRoute(&#123; <span class="hljs-attr">route</span>: <span class="hljs-string">'task/:nr'</span> &#125;, [Div(<span class="hljs-string">'.task-details'</span>, &#123; <span class="hljs-attr">slot</span>: <span class="hljs-string">'tab'</span> &#125;), [ProjectTaskDetails]]),      OnRoute(&#123; <span class="hljs-attr">route</span>: <span class="hljs-string">'comments'</span> &#125;, [Div(<span class="hljs-string">'.comments'</span>, &#123; <span class="hljs-attr">slot</span>: <span class="hljs-string">'tab'</span> &#125;), [ProjectComments]]),      OnRoute(&#123; <span class="hljs-attr">route</span>: <span class="hljs-string">'activities'</span> &#125;, [Div(<span class="hljs-string">'.activities'</span>, &#123; <span class="hljs-attr">slot</span>: <span class="hljs-string">'tab'</span> &#125;), [ProjectActivities]])    ]])  ]]);</code></pre><p>where:</p><ul><li><code>ProjectHeader</code> displays the title of the project together with some description</li><li><code>TabContainer</code> is a container component, also handling the tab logic (i.e. emphasizing the tab which is active)</li><li><code>ProjectTaskList</code> handles displaying the panel which displays a list of tasks, allows to enter a new task, and/or filter the list of tasks. </li><li><code>ProjectTaskDetail</code> handles displaying the details for a task, and allows the user to modify those details</li><li><code>ProjectComments</code> handles displaying the comments for a project </li><li><code>ProjectActivities</code> handles displaying the activities related to a project </li></ul><p>Note how we have nested routes (<code>projects/:projectId/tasks</code>) as naturally as we have flat routes. </p><p>For more details on how the slot logic interacts with the <code>TabContainer</code> component, see the <code>TabContainer</code> code. For the full code and running demo, see <a href="https://github.com/brucou/component-combinators/tree/project-management-app-step-3/examples/AllInDemo" target="_blank" rel="noopener">here</a>. </p><h1 id="Step-4-ProjectTaskList-component"><a href="#Step-4-ProjectTaskList-component" class="headerlink" title="Step 4 : ProjectTaskList component"></a>Step 4 : <code>ProjectTaskList</code> component</h1><p>We will seek to write the <code>ProjectTaskList</code> component as follows:</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> ProjectTaskListContainer = vLift(  div(<span class="hljs-string">'.task-list.task-list__l-container'</span>, &#123; <span class="hljs-attr">slot</span>: <span class="hljs-string">'tab'</span> &#125;, [    div(<span class="hljs-string">'.task-list__l-box-a'</span>, &#123; <span class="hljs-attr">slot</span>: <span class="hljs-string">'toggle'</span> &#125;, []),    div(<span class="hljs-string">'.task-list__l-box-b'</span>, &#123; <span class="hljs-attr">slot</span>: <span class="hljs-string">'enter-task'</span> &#125;, []),    div(<span class="hljs-string">'.task-list__l-box-c'</span>, [      div(<span class="hljs-string">'.task-list__tasks'</span>, &#123; <span class="hljs-attr">slot</span>: <span class="hljs-string">'tasks'</span> &#125;, [])    ])  ]));<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> ProjectTaskList =  Combine(&#123;&#125;, [ProjectTaskListContainer, [    InSlot(<span class="hljs-string">'toggle'</span>, [ToggleButton]),    InSlot(<span class="hljs-string">'enter-task'</span>, [EnterTask]),    InSlot(<span class="hljs-string">'tasks'</span>, [TaskList])  ]]);</code></pre><p>where:</p><ul><li><code>ProjectTaskListContainer</code> is a container component which allocates children content into their<br>slots and applies some styling</li><li><code>ToggleButton</code> handles the tasks filter (values to be picked within <code>All</code>, <code>Open</code>, <code>Done</code>)</li><li><code>EnterTask</code> allows the user to enter a new task for the active project</li><li><code>TaskList</code> displays a list of project tasks, taking into account the task filter set by the user</li></ul><p>Note again how the slot mechanism allows to separate a template (fixed part of the target<br><code>vTree</code>), from the contents filling that template (variable part). It is important to become<br>familiar with the mechanism, as it is fundamental to divide the user interface in ever smaller<br>and isolated pieces. Pay attention also to how slots are declared : either directly through the<br>slot module, or with the <code>InSlot</code> combinator. The latter is useful in combination with other<br>components which do not declare slots for their DOM content, for instance generic components.<br><code>InSlot</code> can also be used to override existing slots for a given component’s DOM content. </p><p>Note the use of the utility function <a href="https://github.com/brucou/component-combinators/blob/master/src/utils.js#L1118" target="_blank" rel="noopener"><code>vLift</code></a>, which takes a <code>Vtree</code> and lifts it into a component (whose only sink is a DOM sink emitting that <code>vTree</code>).</p><p>Let’s go in further details about the <code>EnterTask</code> component (illustrating domain driver write<br>actions), and the <code>ToggleButton</code> component (illustrating local state driver actions).</p><h2 id="Adding-a-task"><a href="#Adding-a-task" class="headerlink" title="Adding a task"></a>Adding a task</h2><p>The <code>EnterTask</code> has obvious specifications:</p><div class="table-container"><table><thead><tr><th>Events</th><th>Actions</th></tr></thead><tbody><tr><td>INIT</td><td>DOM: display input field and <code>Add</code> button</td></tr><tr><td>click on <code>Add</code> button</td><td>domainAction$: add a new task to the project’s tasks entity</td></tr><tr><td></td><td>domainAction$: add a new activity to the project’s activity entity</td></tr></tbody></table></div><p>The relevant state is constituted of:</p><ul><li>relevant information about the project under review</li><li>relevant information about the user (activities are linked to users)</li><li>task description as found in the input field</li></ul><p>We will write the <code>EnterTask</code> component as follows:</p><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">EnterTask</span>(<span class="hljs-params">sources, settings</span>) </span>&#123;  <span class="hljs-keyword">let</span> key = <span class="hljs-number">0</span>;  <span class="hljs-keyword">const</span> &#123; projectFb$, user$, <span class="hljs-built_in">document</span> &#125; = sources;  <span class="hljs-keyword">const</span> &#123; [ROUTE_PARAMS]: &#123; projectId &#125; &#125; = settings;  <span class="hljs-keyword">const</span> taskEnterButtonClick$ = sources[DOM_SINK].select(taskEnterButtonSelector).events(<span class="hljs-string">'click'</span>)  <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> is event -&gt; share</span>    .share();  <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span>: we use a key here which changes all the time to force snabbdom to always render the</span>  <span class="hljs-comment">// input vNodes. Because we read from the actual DOM, the input vNodes are no longer the</span>  <span class="hljs-comment">// soruce of truth for the input state. From a snabbdom point of view, without that key, we</span>  <span class="hljs-comment">// render two exact same vNodes and hence it does not do anything. So we have to force the </span>  <span class="hljs-comment">// update by making the successive vNodes differ.</span>  <span class="hljs-keyword">return</span> &#123;    [DOM_SINK]: taskEnterButtonClick$      .map(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> renderTaskEntryArea(++key))      .startWith(renderTaskEntryArea(++key)),    <span class="hljs-attr">domainAction$</span>: taskEnterButtonClick$      .do(preventDefault)      .withLatestFrom(projectFb$, user$, (ev, projectFb, user) =&gt; &#123;        <span class="hljs-keyword">const</span> &#123;<span class="hljs-attr">fbIndex</span>: projectFbIndex, project&#125; = projectFb;        <span class="hljs-keyword">const</span> tasks = project.tasks;        <span class="hljs-keyword">const</span> newTaskPosition = tasks.length;        <span class="hljs-keyword">const</span> nr = tasks.reduce(<span class="hljs-function">(<span class="hljs-params">maxNr, task</span>) =&gt;</span> task.nr &gt; maxNr ? task.nr : maxNr, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;        <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> has to be computed just before it is used, otherwise might not get the current</span>        <span class="hljs-comment">// value</span>        <span class="hljs-keyword">const</span> _taskEnterDescription = getInputValue(<span class="hljs-built_in">document</span>, taskEnterInputSelector);        <span class="hljs-keyword">const</span> taskEnterDescription = _taskEnterDescription ? _taskEnterDescription: <span class="hljs-string">'Task'</span>;        <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> We have two domain actions to perform here</span>        <span class="hljs-keyword">return</span> $.<span class="hljs-keyword">from</span>([&#123;          <span class="hljs-attr">context</span>: TASKS,          <span class="hljs-attr">command</span>: ADD_NEW_TASK,          <span class="hljs-attr">payload</span>: &#123;            projectFbIndex,            <span class="hljs-attr">newTask</span>: taskFactory(taskEnterDescription, newTaskPosition, nr),            tasks          &#125;        &#125;, &#123;          <span class="hljs-attr">context</span>: ACTIVITIES,          <span class="hljs-attr">command</span>: LOG_NEW_ACTIVITY,          <span class="hljs-attr">payload</span>: activityFactory(&#123;            user,            <span class="hljs-attr">time</span>: +<span class="hljs-built_in">Date</span>.now(),            <span class="hljs-attr">subject</span>: projectId,            <span class="hljs-attr">category</span>: <span class="hljs-string">'tasks'</span>,            <span class="hljs-attr">title</span>: <span class="hljs-string">'A task was added'</span>,            <span class="hljs-attr">message</span>: <span class="hljs-string">`A new task "'A task was added'" was added to #<span class="hljs-subst">$&#123;projectId&#125;</span>.`</span>          &#125;)        &#125;        ])      &#125;)      .switch()  &#125;&#125;</code></pre><p>Note how we use the domain update driver, and request methods execution on domain entities. </p><h2 id="Setting-the-task-filter"><a href="#Setting-the-task-filter" class="headerlink" title="Setting the task filter"></a>Setting the task filter</h2><p>Specifications for the <code>ToggleButton</code> component are as follows:</p><div class="table-container"><table><thead><tr><th>Events</th><th>State</th><th>Actions</th></tr></thead><tbody><tr><td>INIT</td><td>task filter</td><td>DOM: display all tabs, emphasizing the tab corresponding to the task filter (i.e. active tab)</td></tr><tr><td>click on a tab</td><td>task filter</td><td>local state: update the task filter</td></tr></tbody></table></div><p>We will use the in-memory store driver to keep track of the task filter. As the<br> task filter will also be used by the <code>TaskList</code> component to filter out the project’s tasks,<br> it needs to be accessible by several components which are not in a parent/child relationship.<br> There are basically two ways to handle this:</p><ul><li><p>The first one is to create and inject that piece of state at the closest ancestor level (this would be here at <code>ProjectTaskList</code> level). </p><ul><li>The second one is to create that piece of state at the global level (i.e. cutting across the component<br>hierarchy - that is what the in-memory store is), and access it anywhere necessary. </li></ul><p>We chose the second solution for didactic purposes (injecting <code>tasksFilter$</code>), as an example of use of the in-memory store driver. Concretely, the breakdown is as follows:</p></li></ul><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> ToggleButton =  InjectSourcesAndSettings(&#123;      <span class="hljs-attr">sourceFactory</span>: tasksFilter$,      <span class="hljs-attr">settings</span>: tasksButtonGroupSettings    &#125;, tasksButtonGroupSettings.buttonGroup.labels.map(<span class="hljs-function">(<span class="hljs-params">buttonLabel, index</span>) =&gt;</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sources, settings</span>) </span>&#123;        <span class="hljs-keyword">return</span> ButtonFromButtonGroup(sources, merge(settings, &#123;          buttonLabel,          index        &#125;))      &#125;    &#125;)  );</code></pre><p>where the injected state is: </p><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStateInStore</span>(<span class="hljs-params">context, sources, settings</span>) </span>&#123;  <span class="hljs-keyword">const</span> &#123;storeAccess, storeUpdate$&#125; = sources;  <span class="hljs-keyword">return</span>  storeAccess.getCurrent(context)    .concat(storeUpdate$.getResponse(context).map(path([<span class="hljs-string">'response'</span>])))    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> this is a behaviour</span>    .shareReplay(<span class="hljs-number">1</span>)&#125;<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tasksFilter$</span>(<span class="hljs-params">sources, settings</span>) </span>&#123;  <span class="hljs-keyword">return</span> &#123;    <span class="hljs-attr">taskFilter$</span>: getStateInStore(TASKS_FILTER, sources, settings)      .map(prop(<span class="hljs-string">'filter'</span>))      <span class="hljs-comment">// In case the `TASKS_FILTER` entity has changed but the tasks filter property has not</span>      .distinctUntilChanged()  &#125;&#125;</code></pre><p>Note how we combine the store read and write drivers (<code>storeAccess</code>, <code>storeUpdate$</code>) to get<br>a <em>live</em> <code>taskFilter$</code> which emits the current value of the task filter and then the new values of<br>the task filter, every time that value changes. To ensure this, we listen on responses to<br>in-memory entity update requests. Such responses are objects which hold the updated entity in the<br><code>response</code> property. For extra details, refer to the <a href="https://github.com/brucou/component-combinators/blob/master/examples/AllInDemo/src/inMemoryStore/index.js#L21" target="_blank" rel="noopener">configuration</a><br> of the in-memory driver, and at the documentation for the <a href="/projects/component-combinators/actiondriver/">domain <code>Action</code> driver</a>.</p><p>The <code>ButtonFromButtonGroup</code> is a component which will display a button with a label passed<br>through <code>settings</code> and update the task filter when the button is clicked:</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> updateTaskTabButtonGroupStateAction = <span class="hljs-function"><span class="hljs-params">label</span> =&gt;</span> (&#123;    <span class="hljs-attr">context</span>: TASKS_FILTER,    <span class="hljs-attr">command</span>: PATCH,    <span class="hljs-attr">payload</span>: [      &#123; <span class="hljs-attr">op</span>: <span class="hljs-string">"add"</span>, <span class="hljs-attr">path</span>: <span class="hljs-string">'/filter'</span>, <span class="hljs-attr">value</span>: label &#125;,    ]  &#125;);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ButtonFromButtonGroup</span>(<span class="hljs-params">sources, settings</span>) </span>&#123;  <span class="hljs-keyword">const</span> &#123; taskFilter$ &#125; = sources;  <span class="hljs-keyword">const</span> &#123; buttonLabel, index, <span class="hljs-attr">buttonGroup</span>: &#123; labels, namespace, buttonClasses &#125; &#125; = settings;  <span class="hljs-keyword">const</span> buttonGroupSelector = makeButtonGroupSelector(&#123; <span class="hljs-attr">label</span>: buttonLabel, index, namespace &#125;);  <span class="hljs-keyword">const</span> events = &#123;    <span class="hljs-attr">click</span>: sources[DOM_SINK].select(buttonGroupSelector).events(<span class="hljs-string">'click'</span>)      .map(always(buttonLabel))  &#125;;  <span class="hljs-keyword">const</span> state$ = taskFilter$;    <span class="hljs-keyword">return</span> &#123;    [DOM_SINK]: state$.map(<span class="hljs-function"><span class="hljs-params">taskFilter</span> =&gt;</span> &#123;      <span class="hljs-keyword">const</span> classes = [<span class="hljs-string">''</span>]        .concat(buttonClasses(taskFilter, buttonLabel))        .join(<span class="hljs-string">'.'</span>) + buttonGroupSelector;      <span class="hljs-keyword">return</span> button(classes, buttonLabel)    &#125;),    <span class="hljs-attr">storeUpdate$</span>: events.click      .withLatestFrom(state$, (label, taskFilter) =&gt; (&#123; label, taskFilter &#125;))      <span class="hljs-comment">// no need to do anything if clicking on a button already active</span>      .filter(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x.label !== x.taskFilter)      .map(prop(<span class="hljs-string">'label'</span>))      .map(updateTaskTabButtonGroupStateAction)  &#125;&#125;</code></pre><p>Note that <a href="https://github.com/brucou/component-combinators/blob/master/examples/AllInDemo/src/inMemoryStore/index.js#L29" target="_blank" rel="noopener">in-memory store driver</a> uses <a href="http://jsonpatch.com/" target="_blank" rel="noopener">json patch</a> to describe the updates to the in-memory entity.</p><p>For the full code and running demo, see <a href="https://github.com/brucou/component-combinators/tree/project-management-app-step-4/examples/AllInDemo" target="_blank" rel="noopener">here</a>.</p><h2 id="Displaying-a-list-of-tasks"><a href="#Displaying-a-list-of-tasks" class="headerlink" title="Displaying a list of tasks"></a>Displaying a list of tasks</h2><p>A <code>TaskList</code> is a list of tasks. We inject the corresponding state, compute the component with<br><code>ListOf</code> combinator, and affect the DOM content to the corresponding slot:</p><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> TaskList = InjectSourcesAndSettings(&#123; <span class="hljs-attr">sourceFactory</span>: taskListStateFactory &#125;, [TaskListContainer, [  InSlot(<span class="hljs-string">'task'</span>, [    ForEach(&#123; <span class="hljs-attr">from</span>: <span class="hljs-string">'filteredTasks$'</span>, <span class="hljs-attr">as</span>: <span class="hljs-string">'filteredTasks'</span> &#125;, [      ListOf(&#123; <span class="hljs-attr">list</span>: <span class="hljs-string">'filteredTasks'</span>, <span class="hljs-attr">as</span>: <span class="hljs-string">'filteredTask'</span> &#125;, [        EmptyComponent,        Task      ])    ])  ])]]);</code></pre><p>a <code>Task</code> is made of a checkbox to change its status, a button to allow deletion, another button<br>to allow task edition, and the task information. Clicking on a task detail button should route<br>the user to another screen where he can modify the task information. The breakdown is hence<br>as follows: </p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TaskContainer</span>(<span class="hljs-params">sources, settings</span>) </span>&#123;  <span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">filteredTask</span>: &#123; done, title &#125;, listIndex &#125; = settings;  <span class="hljs-keyword">const</span> coreVnodes = div(<span class="hljs-string">'.task'</span>, [    div(<span class="hljs-string">".task__l-box-a"</span>, &#123; <span class="hljs-attr">slot</span>: <span class="hljs-string">'checkbox'</span> &#125;, []),    div(<span class="hljs-string">".task__l-box-b"</span>, [      div(<span class="hljs-string">".task__title"</span>, &#123; <span class="hljs-attr">slot</span>: <span class="hljs-string">'editor'</span> &#125;, []),      button(taskDeleteSelector(listIndex)),      div(<span class="hljs-string">'.task-infos'</span>, &#123; <span class="hljs-attr">slot</span>: <span class="hljs-string">'task-infos'</span> &#125;, []),      div(&#123; <span class="hljs-attr">slot</span>: <span class="hljs-string">'task-link'</span> &#125;, []),    ])  ]);  <span class="hljs-keyword">return</span> &#123;    [DOM_SINK]: $.<span class="hljs-keyword">of</span>(      done        ? div(<span class="hljs-string">`.task--done`</span>, [coreVnodes])        : coreVnodes    )  &#125;&#125;<span class="hljs-keyword">const</span> Task = InjectSourcesAndSettings(&#123;  <span class="hljs-attr">settings</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings</span>) </span>&#123;    <span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">filteredTask</span>: &#123; done, title &#125;, listIndex &#125; = settings;    <span class="hljs-keyword">return</span> &#123;      <span class="hljs-attr">checkBox</span>: &#123; <span class="hljs-attr">isChecked</span>: !!done, <span class="hljs-attr">namespace</span>: [TASKS, listIndex].join(<span class="hljs-string">'_'</span>), <span class="hljs-attr">label</span>: <span class="hljs-literal">undefined</span> &#125;,      <span class="hljs-attr">editor</span>: &#123; <span class="hljs-attr">showControls</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">initialEditMode</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">initialContent</span>: title &#125;    &#125;  &#125;&#125;, [TaskContainer, [  InSlot(<span class="hljs-string">'checkbox'</span>, [    Pipe(&#123;&#125;, [      CheckBox,      ComputeCheckBoxActions    ]),  ]),  InSlot(<span class="hljs-string">'editor'</span>, [    Pipe(&#123;&#125;, [      Editor,      ComputeEditorActions    ]),  ]),  InSlot(<span class="hljs-string">'task-infos'</span>, [    TaskInfo,  ]),  TaskDelete,  InSlot(<span class="hljs-string">'task-link'</span>, [    TaskLink  ]),]]);</code></pre><p>Using <code>CheckBox</code> and <code>Editor</code> generic UI components requires us to do some adaption of input,<br>and output to fit their APIs. This allows to illustrate two interesting techniques:</p><ul><li>Inputs (here <code>settings</code>) are adapted through <code>InjectSourcesAndSettings</code> ahead of using the<br>generic UI components</li><li>Outputs are adapted through the use of the <code>Pipe</code> combinator. For instance, <code>Editor</code> returns a<br><code>save$</code> sink which needs to be mapped to a <code>domainAction</code> sink to update the corresponding domain<br>entity. As a matter of fact, the <a href="/projects/component-combinators/pipe"><code>Pipe</code> combinator</a> allows to pass sinks of a component in the<br>pipe as sources for the next component in the pipe. In the mentioned case, for instance the<br>output adaptation is performed by <code>ComputeEditorActions</code>.</li></ul><h1 id="TIP-How-to-write-a-component"><a href="#TIP-How-to-write-a-component" class="headerlink" title="TIP: How to write a component"></a>TIP: How to write a component</h1><p>Within the chosen architecture (cycle), writing a <em>leaf</em> component, i.e. a component<br>which is not derived from other components, but only from <code>sources</code> and <code>settings</code>, means:</p><ul><li>having clear specifications as per the reactive behaviour to implement<ul><li>from the equation <code>actions = f(state, events)</code>:<ul><li>identify the relevant events the component reacts to</li><li>identify the actions to trigger in response to events</li><li>identify the necessary pieces of state to compute the actions from the events</li></ul></li></ul></li><li>decide on the parameterization of the component<ul><li>this means deciding which parts, if any, of the component’s behaviour will be parameterizable<br>through the component’s <code>settings</code> property</li></ul></li><li>compute the events<ul><li>while doing so, ensure in particular that events are coupled to unique selectors: this is<br>particularly important when operating within the cycle architecture where events are decoupled<br>from the elements that originate them.</li></ul></li><li>compute the necessary pieces of state</li><li>compute the actions, as a function of the events and pieces of state</li></ul><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>We want to implement a <code>NavigationItem</code> component with the following specifications:</p><ul><li>displays a project</li><li>parameterized by a project title and a route corresponding to that project (termed project link)</li><li>if the current route corresponds to the project link, emphasize visually that project </li></ul><p>This gives us, the following reactive function:</p><div class="table-container"><table><thead><tr><th>Events</th><th>Actions</th></tr></thead><tbody><tr><td>INIT (route == project link)</td><td>DOM: display project title</td></tr><tr><td>INIT (route != project link)</td><td>DOM: display emphasized project title</td></tr><tr><td>click on project title</td><td>router: navigate to the project link</td></tr></tbody></table></div><p>This helps us identifying the pieces of state part of the reactive function:</p><div class="table-container"><table><thead><tr><th>Events</th><th>State</th><th>Actions</th></tr></thead><tbody><tr><td>INIT</td><td>isLinkActive: true (i.e. <code>route == project link</code>)</td><td>DOM: display project title</td></tr><tr><td>INIT</td><td>isLinkActive: false (i.e. <code>route != project link</code>)</td><td>DOM: display emphasized project title</td></tr><tr><td>click on project title</td><td>—</td><td>router: navigate to the project link</td></tr></tbody></table></div><p>We assure the unicity of the selector for the click event, by coupling the corresponding element<br>to the project link, which is unique as per the specification. This is a tradeoff of <code>cyclejs</code>‘s<br>architectural choice to separate the event creation from the declaration of the view structure.<br>As a matter of fact, the view is conceptually tightly coupled to the event handlers, and forcing<br>the decoupling of the two results in having to define unequivocally, for each event handler, the DOM element to<br>which it relates. On the positive side of that tradeoff, we are able to test components, by<br>mocking their inputs. For readability and DRY reasons, we recommend to isolate the <code>css</code> selector by<br>which event handler and element are coupled into a separate variable. </p><p>This leads to the implementation below: </p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">NavigationItem</span>(<span class="hljs-params">sources, settings</span>) </span>&#123;  <span class="hljs-keyword">const</span> &#123; url$ &#125; = sources;  <span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">project</span>: &#123; title, link &#125; &#125; = settings;  <span class="hljs-keyword">const</span> linkSanitized = link.replace(<span class="hljs-regexp">/\//i</span>, <span class="hljs-string">'_'</span>);  <span class="hljs-keyword">const</span> events = &#123;    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> we avoid having to isolate by using the link which MUST be unique over the whole</span>    <span class="hljs-comment">// application (unicity of a route)</span>    click: sources.DOM.select(<span class="hljs-string">`.navigation-section__link.<span class="hljs-subst">$&#123;linkSanitized&#125;</span>`</span>).events(<span class="hljs-string">'click'</span>)  &#125;;  <span class="hljs-keyword">const</span> state$ = url$    .map(<span class="hljs-function"><span class="hljs-params">url</span> =&gt;</span> url.indexOf(link) &gt; <span class="hljs-number">-1</span>)    .shareReplay(<span class="hljs-number">1</span>);  <span class="hljs-keyword">const</span> actions = &#123;    <span class="hljs-attr">domUpdate</span>: state$.map(<span class="hljs-function"><span class="hljs-params">isLinkActive</span> =&gt;</span> &#123;      <span class="hljs-keyword">const</span> isLinkActiveClass = isLinkActive ? <span class="hljs-string">'.navigation-section__link--active'</span>: <span class="hljs-string">''</span>;      <span class="hljs-keyword">return</span> a(        <span class="hljs-string">`<span class="hljs-subst">$&#123;isLinkActiveClass&#125;</span>.navigation-item.navigation-section__link.<span class="hljs-subst">$&#123;linkSanitized&#125;</span>`</span>,        &#123; <span class="hljs-attr">attrs</span>: &#123; <span class="hljs-attr">href</span>: link &#125;, <span class="hljs-attr">slot</span>: <span class="hljs-string">'navigation-item'</span> &#125;,        title)    &#125;),    <span class="hljs-attr">router</span>: events.click      .do(preventDefault)      .map(always(<span class="hljs-string">'/'</span> + link + <span class="hljs-string">'/'</span>))  &#125;  <span class="hljs-keyword">return</span> &#123;    [DOM_SINK]: actions.domUpdate,    <span class="hljs-attr">router</span>: actions.router  &#125;&#125;</code></pre><h1 id="TIP-How-to-write-a-component-combinator"><a href="#TIP-How-to-write-a-component-combinator" class="headerlink" title="TIP: How to write a component combinator"></a>TIP: How to write a component combinator</h1><p>We have already given two examples of component combinators (<a href="/posts/applying-componentization-to-reactive-system---sample-application/#navigation-combinator">here</a>, and <a href="/posts/applying-componentization-to-reactive-system---sample-application/#navigationsection-combinator">here</a>). The general<br>process is as follows:</p><ul><li>having clear specifications as per the combining behaviour to implement<ul><li>how is the component combinator to be parameterized ?</li><li>is a container component necessary ?</li><li>what are the contracts which settings or component tree must fulfill?</li><li>how are the components’ sinks combined?<ul><li>are default combining functions sufficient ?</li><li>are specific combining functions necessary ?</li></ul></li></ul></li><li>implement the target behaviour<ul><li>reuse as much as possible existing combinators</li><li>select, when necessary, the most appropriate form of the <code>m</code> combinator (out of the three<br>reducing patterns)<ul><li>reminder: <code>= m(componentCombinatorSpec, componentCombinatorSettings,childrenComponents | componentTree)</code></li><li>understanding <code>m</code> default reducing functions is paramount: often times, they have the<br>behaviour that is sought for</li></ul></li></ul></li></ul><h1 id="Generic-reusable-components"><a href="#Generic-reusable-components" class="headerlink" title="Generic, reusable components"></a>Generic, reusable components</h1><p>Components developed for a specific application usually have to be generalized to make them<br>reusable. The generalized component can then be adapted, specialized or parameterized to be used<br>for the specific application use case.</p><p>For instance, in our application’s UI, we have a checkbox on which a click leads to miscellaneous<br>actions on the domain model. Abstracting out the actions specific to the domain model, we can<br>build a reusable checkbox UI component, where the clicks will emit a dummy action passing on the<br>status of the checkbox (checked/unchecked).</p><p>That generic UI checkbox can then be reused in different contexts, within the application, or in<br>other applications, by specifying how the clicks translates into actions on the given domain<br>model: the UI checkbox component is <strong>adapted</strong> to the application under development.</p><p>In other cases, the generalized component will be specialized (the <code>m</code> combinator is such a case,<br> where the programmer can specialize the reduction of the component tree to one of three patterns).</p><p>In yet other cases, the generalized component behaviour will be configured by parameterization<br>through the component settings.</p><p>In our application, we have identified the following reusable UI components:</p><ul><li><code>CheckBox</code> component<ul><li>for each click on the checkbox, passes the state of that checkbox  </li></ul></li><li><code>Editor</code> component<ul><li>allows to define an editable user content zone where the user can modify, save, delete<br>content.</li></ul></li></ul><p>Potential candidates for further refactoring into reusable components are:</p><ul><li>ToggleButton (<em>xor</em> button group component)</li><li>EnterTask (input entry)</li></ul><p>A component such as <code>TaskInfo</code> is not a fruitful target for a generalization that allows to reuse<br>it in other domains, as its behaviour seems very much tied (coupled) to the application’s domain<br>model. However, should that component be needed with slight modifications more than twice (<a href="https://en.wikipedia.org/wiki/Rule_of_three_(computer_programming" target="_blank" rel="noopener">rule of three</a>) in our application, we would have considered<br>writing a generalized version of the component.</p><p>Ideally, there is already at hand a component (UI or domain) )library that is already tested, and<br>documented. That could be the case for example for UI components, such as those exposed<br>previously. This could also be the case if domain experts have succeeded in identifying repeating<br> patterns in their domain, and produced a domain-specific component library. In the general case,<br>  the software designer will have to find and assess the abstraction/generalization opportunities presented to<br> him. Those opportunities are generally identified while refactoring. As explained in a <a href="/posts/componentization-against-complexity/#barriers-to-reuse">former article</a>, refactoring for reuse has a<br> cost, and the possible benefits to be derived have to be weighted against that cost.</p><p>For illustration purposes, here is part of the source code for the <code>CheckBox</code> component:</p><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CheckBox</span>(<span class="hljs-params">sources, settings</span>) </span>&#123;  <span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">checkBox</span>: &#123; <span class="hljs-attr">label</span>: _label, namespace, isChecked &#125; &#125; = settings;  <span class="hljs-keyword">const</span> checkBoxSelector = <span class="hljs-string">'.'</span> + [defaultTo(defaultNamespace, namespace), ++counter].join(<span class="hljs-string">'-'</span>);  <span class="hljs-keyword">const</span> __label = defaultTo(<span class="hljs-string">''</span>, _label);  assertContract(isCheckBoxSettings, [settings.checkBox], <span class="hljs-string">`CheckBox: Invalid check box settings!: <span class="hljs-subst">$&#123;format(settings.checkBox)&#125;</span>`</span>)  <span class="hljs-keyword">const</span> events = &#123;    <span class="hljs-string">'change'</span>: sources[DOM_SINK]      .select(checkBoxSelector).events(<span class="hljs-string">'change'</span>)      .map(<span class="hljs-function"><span class="hljs-params">ev</span> =&gt;</span> ev.target.checked)  &#125;;  <span class="hljs-keyword">return</span> &#123;    [DOM_SINK]: $.<span class="hljs-keyword">of</span>(div(<span class="hljs-string">'.checkbox'</span>, [      label(labelSelector, [                input([inputSelector, checkBoxSelector].join(<span class="hljs-string">''</span>), &#123;                  <span class="hljs-string">"attrs"</span>: &#123;                    <span class="hljs-string">"type"</span>: <span class="hljs-string">"checkbox"</span>,                    <span class="hljs-string">"checked"</span>: isChecked,                  &#125;                &#125;),                span(checkBoxTextSelector, __label)              ])    ])),    <span class="hljs-attr">isChecked$</span>: events.change  &#125;&#125;</code></pre><p>The <code>isChecked$</code> sink can later on be used in coordination with the <code>Pipe</code> combinator to produce<br>the desired sink.</p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>We have seen while implementing the sample application how to address common issues arising when implementing a web application:</p><ul><li><strong>routing</strong>: a quintessential requirement such as routing is very naturally expressed with<br>the <code>OnRoute</code> combinator.</li><li><strong>state management</strong>: state can be injected at any point of the component tree and becomes<br>visible to any component down the injection point. Alternatively, state can also be kept at the<br>root level, through the use of in-memory store.</li><li><strong>change propagation</strong>: at the lowest level, using streams as the corner stone of our<br>architecture solves the issue of updating a variable (behaviour) when one of its dependencies<br>change. <em>Live queries</em> can then be built on top of read and write drivers as exemplified in the<br>sample application. Additionally, we offer the <code>ForEach</code> combinator, to execute a given logic on<br>a every change of a behaviour. </li><li><strong>communication between components</strong>: parent-child communication may occur through passing<br>settings and sources, child-parent communication and communication between components with no<br>direct ascendency relationship in the component tree may occur via shared state. </li><li><strong>lists</strong>: list of things are dealt with reactively with the <code>ListOf</code> and <code>ForEach</code> combinators. </li></ul><p>While these were not encountered in the present sample application, our combinator library also helps deal with:</p><ul><li><strong>control flow</strong>: Two combinators (<code>Switch</code> and <code>FSM</code>) allow to implement both simple and complex control flow logic. A <a href="https://github.com/brucou/component-combinators/tree/master/examples/volunteerApplication" target="_blank" rel="noopener">realistic example</a> for the <code>FSM</code> combinator showcases the advantage of state machines to that purpose.</li></ul><p>We have showcased our componentization model, and the accompanying combinator library. By dividing the target reactive system into smaller components, and expliciting the event-state-action relation, it is possible to reach a breakdown where each leaf component is easy to write. At the same time, those relatively independent components are glued into the cohesive whole that is the target application, in a way that is made both concise and readable by the use of combinators.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;As discussed in a &lt;a href=&quot;/po
      
    
    </summary>
    
      <category term="programming" scheme="https://brucou.github.io/categories/programming/"/>
    
    
      <category term="functional programming" scheme="https://brucou.github.io/tags/functional-programming/"/>
    
      <category term="reactive programming" scheme="https://brucou.github.io/tags/reactive-programming/"/>
    
      <category term="components" scheme="https://brucou.github.io/tags/components/"/>
    
  </entry>
  
  <entry>
    <title>A componentization model for cyclejs</title>
    <link href="https://brucou.github.io/2017/07/07/A%20componentization%20framework%20for%20cyclejs/"/>
    <id>https://brucou.github.io/2017/07/07/A componentization framework for cyclejs/</id>
    <published>2017-07-06T22:00:00.000Z</published>
    <updated>2019-05-26T03:40:06.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>A component framework or platform provides both a systematic method to construct components, possibly from other components (namely dealing with interfacing, binding and interactions between components), and a systematic interface between component and the component framework, by which components can be introspected, instantiated, executed, destroyed (namely dealing with component lifecycle)<sup><a href="#fn_classification" id="reffn_classification">classification</a></sup>.</p><blockquote id="fn_classification"><sup>classification</sup>. Cf. <a href="https://pdfs.semanticscholar.org/04ab/304cd8102fdbecd6a41cde9a934e1567b1b3.pdf" target="_blank" rel="noopener">A classification framework for software component models</a><a href="#reffn_classification" title="Jump back to footnote [classification] in the text."> &#8617;</a></blockquote><p>The first figure shows a classification framework for software component models, emphasizing the miscellaneous responsibilities of a component model.</p><p><img src="https://i.imgur.com/9yziyvB.png" alt="Classification framework for software component models"></p><p>The second figure illustrates construction mechanisms linking components to each other and to the component framework.</p><p><img src="https://i.imgur.com/mLozPJ4.png" alt="Component framework"></p><p>The third figure illustrates the two key ways to interface components : operational-based interface, or port-based interface.</p><p><img src="https://i.imgur.com/t84fq4c.png" alt="Interface specification"></p><p>We will thereafter expose our proposal for a componentization model for implementing reactive systems, based on <code>rxjs</code> as a streaming technology,<code>cyclejs</code> as an architecture and framework, and component combintators to break down a reactive application into a component tree<br>. Characteristics of a good decomposition will be presented. We will also address how our<br>component model handles common cross-cutting concerns, such as state management, concurrency<br>control, and error handling. </p><h1 id="Proposed-component-framework"><a href="#Proposed-component-framework" class="headerlink" title="Proposed component framework"></a>Proposed component framework</h1><p>We have seen <a href="/posts/user-interfaces-as-reactive-systems/">previously</a> that to implement a reactive system we need :</p><ul><li>a reactive function $f$ linking actions to events, with $actions = f(events)$, where actions<br>and events are represented as streams</li><li>an interface with the systems through which actions intended by the user must be performed</li><li>an interface by which the reactive system receives its events</li></ul><p>Our component framework will be inspired by <code>cyclejs</code> framework. A component will be a procedure <code>f :: Sources -&gt; Settings -&gt; Sinks</code>, where :</p><ul><li><code>Sources</code> contains any necessary accessor/factory methods to the internal state of the framework and relevant events</li><li><code>Settings</code> represents the parameterization concern of the component behaviour</li><li><code>Sinks</code> holds the computed action representations in response to incoming events</li></ul><p>In the context of cyclejs, the equation hence changes to $actions = f(sources, settings)$. Note<br>that $f$ here is not in general a pure function, as typically $f$ is accessing the external world to read events from it. We will still call $f$ the reactive function, by abuse of language. It would be easy to write <code>f = compose(g, h)</code> where <code>h :: Sources -&gt; Settings -&gt; Events</code> and <code>g :: Events -&gt; Settings -&gt; Sinks</code>, so that <code>g</code> is a pure function. We however follow <code>cyclejs</code> choice here and accept an impure reactive function, for reasons we will detail thereafter.</p><p>The component framework exposes an interface to its components by which it receives the actions to be performed : <code>Sinks :: HashMap&lt;SinkName, Sink&gt;</code>, is to be matched with <code>Drivers :: HashMap&lt;SinkName, Driver&gt;</code>, where a <code>Driver :: Sink -&gt; Source</code> takes responsibility for the <strong>execution</strong> of actions passed through the <strong>matching</strong> sink, and passing up the eventual results of such actions as an event into the reactive system.</p><p>The component framework also exposes the interface by which the reactive system receives its events<br> : <code>Sources :: HashMap&lt;SourceName, Source&gt;</code>, where <code>Source</code> is anything presenting an interface to access <strong>events</strong> and <strong>state</strong> from/of external systems of interest. <code>Source</code> can, for instance, be a parameterizable event factory (events obtained from DOM listeners, etc.). <code>SourceName</code> is a moniker uniquely referencing the corresponding source of events.</p><p>The component framework connects together identical <code>SourceName</code> and <code>SinkName</code>, so that a driver corresponding to a given <code>SinkName</code> will output the result of the actions it executes, as events with the same moniker (<code>SourceName</code> — in figure thereafter, represented<br>with same colour).</p><p><img src="/img/graphs/cycle_component_framework.png" alt="cyclejs framework"></p><p>In the context of cyclejs, component composition can be based on standard function<br>composition, with message-passing/dataflow through streams and a port-based interface emulated by the monikers <code>SinkName</code>, <code>SourceName</code>. It is the simplicity of that interface (standard function composition) which motivates renouncing the purity<br> of the reactive function.</p><p>In the context of our component model, component composition is performed via what we term<br>component combinators. We will review in what follows parallel composition, sequential composition,<br>parametricity and genericity, all of which being concerns incorporated into the component<br>combinators.</p><h2 id="Parallel-composition"><a href="#Parallel-composition" class="headerlink" title="Parallel composition"></a>Parallel composition</h2><p>Parallel composition in our context is based on expressing the reactive function $f$ as the combination of functions, each of which captures a smaller and ideally isolated part of the overall $f$’s complexity.</p><p>The bet is that :</p><ul><li>the smaller functions will lead to lower complexity,</li><li>that complexity will be low enough to be addressed satisfactorily at the smaller function level,</li><li>$f$ can be recombined in a systematic way without loss in specification from the smaller functions</li><li>it will be possible to encapsulate a large class of reactive subsystems into reusable generic components, which can then be parameterized to reflect the targeted reactive subsystem at hand.</li></ul><p>In short, we want a <code>combine :: Array&lt;Component&gt; -&gt; Component</code>, where :</p><ul><li>$f$, the reactive function is a <code>Component</code></li><li>$f$ can be obtained by applying <code>combine</code> to other reactive functions<ul><li>$f = combine([f_1, f_2, f_3…])$</li></ul></li></ul><p>Note that :</p><ul><li>the <code>combine</code> function can take any extra arguments, in which case, by partial application, it is always possible to come back the canonical <code>combine</code> form shown previously.</li><li>As any component used to derive another component can itself have been derived, parallel composition naturally leads to component trees</li></ul><p>There are usually many ways to perform that decomposition. The idea in every case is to reach functions $f_{m.n…}$ whose complexity is easily manageable. If we understand that part of complexity of such functions emanates from the top-level $f$, while another part stems from the interaction of $f_{m.n…}$s with the larger reactive system, we see that there is a sweet spot where the function is ‘small’ enough to be manageable but not too small so it has to be coupled with many other functions to achieve a given functionality (<strong>coupling increases complexity</strong>).</p><h2 id="Sequential-composition"><a href="#Sequential-composition" class="headerlink" title="Sequential composition"></a>Sequential composition</h2><p>We seek <code>combine :: Array&lt;Component&gt; -&gt; Component</code>, where :</p><ul><li>$combine([f]) = f$</li><li>$combine([f, g])$<ul><li>only defined when f and g have at least one matching output/input</li><li>connect input of $g$ to output of $f$</li></ul></li></ul><p>As a side effect, sequential composition can be used for interface adaptation purposes, like in<br>$combine([adaptInput, f, adaptOutput])$.  </p><h2 id="Genericity-parametricity-and-reuse"><a href="#Genericity-parametricity-and-reuse" class="headerlink" title="Genericity, parametricity and reuse"></a>Genericity, parametricity and reuse</h2><p>At the core of reusability of components is the ability to design components implementing a behaviour which is generic enough to cover a large set of contexts, and parameterizable enough to be customized at design-time or run-time without modification.</p><p>In this effort, as previously introduced, we will address the parameterization concern with a specific parameter (<code>:: Settings</code>) passed to the reusable component factories or combinators. For instance a <code>CheckBox</code> component implementing the generic reactive system made of a checkbox which when clicked emits an action including its checked/unchecked state,  could be written to be parameterized in appearance/style (allowing to customize the checkbox background for example) :</p><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CheckBox</span>(<span class="hljs-params">sources, settings</span>) </span>&#123;  <span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">checkBox</span>: &#123; <span class="hljs-attr">label</span>:_label, namespace, isChecked &#125; &#125; = settings;  <span class="hljs-keyword">const</span> checkBoxSelector = <span class="hljs-string">'.'</span> + [defaultTo(defaultNamespace, namespace), ++counter].join(<span class="hljs-string">'-'</span>);  <span class="hljs-keyword">const</span> __label = defaultTo(<span class="hljs-string">''</span>, _label);  assertContract(isCheckBoxSettings, [settings.checkBox], <span class="hljs-string">`CheckBox : Invalid check box settings! : <span class="hljs-subst">$&#123;format(settings.checkBox)&#125;</span>`</span>)  <span class="hljs-keyword">const</span> events = &#123;    <span class="hljs-string">'change'</span> : sources[DOM_SINK].select(checkBoxSelector).events(<span class="hljs-string">'change'</span>)      .map(<span class="hljs-function"><span class="hljs-params">ev</span> =&gt;</span> ev.target.checked)  &#125;;  <span class="hljs-keyword">return</span> &#123;    [DOM_SINK]: $.<span class="hljs-keyword">of</span>(div(<span class="hljs-string">'.checkbox'</span>, [      label(labelSelector, [                input([inputSelector, checkBoxSelector].join(<span class="hljs-string">''</span>), &#123;                  <span class="hljs-string">"attrs"</span>: &#123;                    <span class="hljs-string">"type"</span>: <span class="hljs-string">"checkbox"</span>,                    <span class="hljs-string">"checked"</span>: isChecked,                  &#125;                &#125;),                <span class="hljs-comment">// NOTE : !! snabbdom overload selection algorithm fails if last input is undefined</span>                span(checkBoxTextSelector, __label)              ])    ])),    <span class="hljs-attr">isChecked$</span>: events.change  &#125;&#125;</code></pre><h2 id="Component-combinators"><a href="#Component-combinators" class="headerlink" title="Component combinators"></a>Component combinators</h2><p>A component combinator is a function of the type <code>Combinator :: Settings -&gt; Array&lt;Component&gt; -&gt; Component</code>. The signature is basically the formerly presented <code>combine</code> signature to which <code>Settings</code> have been added to allow to parameterize the behaviour of the combinator.</p><p>Those combinators are themselves specialization of a generic combinator, here called <code>m</code>, with <code>m :: CombinatorSpecs -&gt; Settings -&gt; Array&lt;Component&gt; -&gt; Component</code>, which can also be written <code>m :: CombinatorSpecs -&gt; Combinator</code>. That is, one can see <code>m</code> both as a combinator factory, or a component factory.</p><p>We have so far implemented a list of combinators which allow to realize the following<br>type of composition :</p><ul><li><strong>Parallel composition</strong><ul><li>merge reactive functions</li><li>switch reactive functions according to events</li><li>recursively switching reactive functions according to route (i.e. nested routing)</li><li>merge a list of reactive functions based on a template and incoming array</li><li>extend a reactive function to process additional events or add extra parameterization</li><li>build a set of reactive functions into a state machine</li></ul></li><li><strong>Sequential composition</strong> of ‘’reactive’’ functions (in quotes here, because the<br>sequentially composed functions are not necessarily reactive functions in the sense that some may not compute actions but intermediary results which serve to compute actions)<ul><li><code>Pipe</code> combinator</li></ul></li></ul><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>We will take as target application an example application from the book <code>Mastering Angular2 components</code>. </p><p><img src="/img/screens/main_screen_ang2_example.png" alt="Example application&#39;s main screen"></p><p>That screen is broken down in non-overlapping regions. For each region, a component is assigned the responsibility to implement the corresponding reactive system. For instance, the menu on the left is taken care of by <code>SidePanel</code>, while the right part is handled by <code>MainPanel</code>. At a high-level, we have the following component tree, where we can see a few component combinators (injecting remote data to be used in that branch of the tree, and adding the application container) :</p><p><img src="/img/graphs/App_Component_Tree_Direct_Lowest_Detail.png" alt="First level of decomposition"></p><p>Iterating on that process, we reach a more detailed component tree, with components catering to more and more specific concerns. The following picture shows how the main panel has been further broken down into smaller components, linked through combinators :</p><p><img src="/img/graphs/App_Component_Tree_ProjectTaskList_with_leaves_out_flat.png" alt="Detailed component tree with combinators"></p><p>As apparent from the figure, the <code>MainPanel</code> handles three routes, one of which corresponds to<br>the <code>Project</code> component, which, among other things, handles a <code>ProjectsTaskList</code>.</p><p>That <code>ProjectsTaskList</code> itself is implemented as follows:</p><p><img src="/img/graphs/App_Component_Tree_ProjectTaskList_with_leaves_flat.png" alt="Detailed component tree with combinators"></p><p><img src="/img/graphs/legend.jpg" style="width:30%"></p><p>From the breakdown of the components, one can easily gather that the <code>ProjectsTaskList</code> is a<br><code>TaskList</code>, which is a list (<code>ListOf</code>) of <code>Task</code>, read remotely (through <code>InjectSourcesAndSettings</code>) and updated for each change of that list (<code>ForEach</code>), and displayed within a <code>TaskListContainer</code>. Additionally,<br>it displays a <code>ToggleButton</code> next to a <code>EnterTask</code> component, all enclosed in a<br><code>ProjectTaskListContainer</code>.</p><h1 id="Characteristics-of-a-good-decomposition"><a href="#Characteristics-of-a-good-decomposition" class="headerlink" title="Characteristics of a good decomposition"></a>Characteristics of a good decomposition</h1><p>A good decomposition should :</p><ul><li>decide on the ideal granularity of the decomposition</li><li>identify generic reusable components</li><li>exhibit high cohesion and loose coupling</li></ul><h2 id="Granularity-of-decomposition"><a href="#Granularity-of-decomposition" class="headerlink" title="Granularity of decomposition"></a>Granularity of decomposition</h2><p>As previously seen, breaking down the system in loosely coupled parts results in the individual parts having lower complexity. The right level of granularity comes from the tradeoff between fine-grain componentization (large number of small and relatively simple components) and coarse grain componentization (small number of large and relatively complex components). On the one hand, finer grain components are simpler to implement. On the other hand, decomposition into a large number of fine-grain components makes the interactions among components voluminous. In that case, the corresponding increase in complexity may overweight the decrease in complexity experienced in the individual components, nullifying the benefits of componentization.</p><p>Additionally there might be non-functional costs to decomposition which becomes non-neglectable at a fine-grain level (performance, resource consumption, etc.). Hence the optimal granularity of a decomposition must be assessed on a case-by-case basis.</p><p>Hierarchical decomposition (where components are themselves composed from other components, termed as children components) helps alleviate somewhat issues from fine-grain decomposition, by containing the increase in interaction between components (interaction is restricted to the scope of the parent component). As we saw before, this hierarchical decomposition gives birth to a component tree, where each parent component (node) is connected to its children (subtrees).</p><p>A system with hierarchical modularity can be viewed at different granularities, from coarser grain at the top of the hierarchy to a finer grain at the bottom. The goal is to constrain the interacting modules at each level to an understandable number while avoiding constraints linked to the total number of components.</p><p>System design is top-down: first the coarse-grain modularity is established, and at each successive phase the next level of hierarchy is established by decomposition of the modules at the next higher level. System implementation, on the other hand, is bottom-up: Only the modules at the leaves of a hierarchy are actually implemented, while each module above is integrated from existing modules below, starting at the bottom.</p><p>The <a href="#example">example</a> provided allows to illustrate the additional point :</p><ul><li>implementation can be performed by successive or parallel refinements. In the example, one can<br>find in green components which are still big and pending breakdown. While focusing on the rest<br>of the implementation, a developer can use a placeholder component (<code>DummyComponent</code>).<br>Alternatively, the component in question can be safely delegated to another developer or another<br>team</li></ul><h2 id="Generic-components-vs-ad-hoc-components"><a href="#Generic-components-vs-ad-hoc-components" class="headerlink" title="Generic components vs. ad-hoc components"></a>Generic components vs. ad-hoc components</h2><p>Two main drivers lead decomposition :</p><ul><li><strong>reusing</strong> already existing components<ul><li>in the context of reactive systems, this mostly involves reusing common presentational/behavioural functionalities : tabbed groups, cards, breadcrumbs, etc. An existing library of reusable components can be leveraged to that effect. Those components however have to be customizable per the actions triggered by user events, or offer an interface decoupled from such actions, i.e. decoupled from the domain at hand.</li></ul></li><li><strong>separating</strong> concerns<ul><li>typically a graphical application will have events belonging to a specific region of the screen. An obvious divide-and-conquer strategy is to break down the application in such independent regions and assign a component to each of those. A component could for instance handle the navigation concern of the application, while another might handle displaying a domain object and possible interactions with that object, with yet another handling notifications from external systems to the application.</li></ul></li></ul><p>It is in addition worthy to identify domain-specific components, should they arise from the application implementation. This might be for instance in the case of a trading application, components which display value of a stock in real-time.</p><p>The <a href="#example">example</a> provided allows to illustrate those points by emphasizing and<br>distinguishing generic UI component from ad-hoc components from container components. </p><h1 id="Cross-cutting-concerns"><a href="#Cross-cutting-concerns" class="headerlink" title="Cross-cutting concerns"></a>Cross-cutting concerns</h1><h2 id="State-management"><a href="#State-management" class="headerlink" title="State management"></a>State management</h2><p>We distinguish 3 types of state :</p><ol><li>Locally persisted state<ul><li>copy of remote data</li><li>locally generated data<ul><li>browser state<ul><li>route</li></ul></li><li>app state</li><li>session state</li><li>page state<ul><li>ui (scrollbar position, checkbox state, etc.)</li><li>user scripts</li></ul></li></ul></li></ul></li><li>Remotely persisted state<ul><li>domain data</li></ul></li><li>Non-persisted state (also termed transient state)<ul><li>Existence is dependent and connected to the lifecycle of the component which originates it</li></ul></li></ol><h3 id="Locally-persisted-state"><a href="#Locally-persisted-state" class="headerlink" title="Locally persisted state"></a>Locally persisted state</h3><h4 id="Fetching-remote-data"><a href="#Fetching-remote-data" class="headerlink" title="Fetching remote data"></a>Fetching remote data</h4><p>Remote data is fetched from its remote source via the corresponding driver, and becomes locally<br>persisted data. The fetch can be a snapshot (no synchronisation with the source), or act like a<br>live query (updating itself whenever the source updates itself). Using streams makes the second<br>option easy to handle in the program. </p><p>In our example, we use a <code>Query</code> driver to fetch remote data from a repository. That query driver<br> needs a context from which it knows (having been configured prior to its use) how to retrieve<br> the remote data. The <code>Query</code> driver is meant to be used in connection with the application<br> domain. The context here can be anything, but with a complex domain, it could be a bounded<br> context of the domain. For more details about usage of <code>Query</code> driver, please refer to the<br> documentation and related tests.  </p><p>Depending on the underlying repository, <code>Query</code> can return just a snapshot (normal case), or a<br>live query (updating with the remote repository). For instance, with <code>Firebase</code>, <code>Query</code> could<br>return a live query. For databases which do not support live updates, it is however possible to<br>simulate it, by using a <code>Command</code> or <code>Action</code> driver, which notifies of the new value every time<br>there is an update on a dependency of the query. Please refer to the <a href="/posts/applying-componentization-to-reactive-systems---sample-application/#step-4-projecttasklist-component">examples (<code>function getStateInStore</code>)</a> to see that<br>technique in application.</p><h4 id="Local-state"><a href="#Local-state" class="headerlink" title="Local state"></a>Local state</h4><p>Local state comes from different sources, originating in different local systems with which the<br>user is interacting. Of particular interest are the application, the page, and the browser.</p><p>Page and browser state can be retrieved by the appropriate interfaces defined by their<br>specifications. We will focus here on explaining how to manage local state related to the<br>application.</p><p>To display a view, we often need pieces of application state that are relevant to that view.<br>Because all inputs to our function are to be taken from <code>Sources</code>, it is necessary for the<br>framework to initialize <code>Sources</code> so that any piece of application state can be generated from it.<br>Typically, this involves copying locally some remotely stored domain data, in addition to<br>initializing some application-specific properties at start-up time. State, evolving over time, is<br>conveniently modelized as a behaviour.</p><p>We recommend to generate the necessary pieces of state as close as possible to where it is needed<br> in the component hierarchy. The figure reproduced thereafter serves to illustrate that point.<br> The top-level state is passed down the hierarchy, where it is massaged into new pieces of state<br> by the <code>InjectSourcesAndSettings</code> combinator. As components <code>A</code> and <code>B</code> needs the same piece of<br> state, that piece of state is injected at the closest common ancestor level. However, only<br> component <code>D</code> requires an additional piece of state, hence that piece of state is injected only<br> for it. </p><p><img src="/img/graphs/state_injection.png" alt="state management"></p><p>Note that the new pieces of state computed by the state injection combinators (<code>InjectSources</code>,<br><code>InjectSourcesAndSettings</code>) are <strong>added</strong> to existing pieces of state, and can be generated from<br>already generated pieces of state, or through some factory in <code>Sources</code> (<code>Query</code> driver for<br>instance - see yellow pills for component <code>D</code>).</p><h3 id="Remotely-persisted-state"><a href="#Remotely-persisted-state" class="headerlink" title="Remotely persisted state"></a>Remotely persisted state</h3><p>This category includes whatever sits in remote databases, but also in any system of interest (for<br> instance banking information accessible through a gateway interface). Remotely persisted state<br> must be queried, in our architecture, through drivers. We recommend here a custom or customized<br> driver which reflects the peculiarity of the domain at hand. See the [<code>Action</code>]<br> (/projects/component-combinators/actiondriver) and <a href="/projects/component-combinators/querydriver"><code>Query</code></a><br> driver for an example.</p><h3 id="Transient-state"><a href="#Transient-state" class="headerlink" title="Transient state"></a>Transient state</h3><p>This is a piece of state which lasts only as long as the component that created it in the first<br>place. Transient state has no need to be kept around and is recreated when needed. As an example, a<br>search-as-you-type component might keep track of the length of the search key, and perform search<br> API calls only when that length has reached a minimum value. The length of the entered search key<br> would be transient state. Transient state may be created through the stream <code>scan</code> operator.</p><h2 id="Concurrency-control"><a href="#Concurrency-control" class="headerlink" title="Concurrency control"></a>Concurrency control</h2><p>User interfaces are inherently concurrent due to their interfacing with <strong>distributed</strong> systems,<br>and the ability for the user to continue to perform inputs triggering new actions irrespectively of<br>the in-process action. </p><p>This often leads to a host of concurrency problems, among which :</p><ul><li>consistency<ul><li>optimistic updates means that a user interface can fall out of synchronization vs. external<br>systems of interest. Possible resynchronization actions may go against already performed<br>actions, if the user interface is not carefully designed or implemented</li></ul></li><li>race conditions<ul><li>lost update : two user-triggered actions, fired in close sequence, write to the same piece of<br>data (write-write concurrency). Under some conditions, one of the two writes can be lost. </li></ul></li><li>order violation<ul><li>the user enters a sequence of inputs, triggering a sequence of actions. However those actions<br>are not executed in the same order than they were generated</li></ul></li><li>missed signal<ul><li>an action is supposed to return a result, and the user interface awaits for such. However,<br>that action result never occurs</li></ul></li></ul><p>This is further compounded by : </p><ul><li>modern applications straying away from javascript’s single-threaded model, with the use of web workers. </li><li>some applications being also concurrent by design (collaborative applications, multi-windows<br>applications, etc.)</li></ul><p>For simple synchronization cases, keeping track of concurrent actions execution in some local<br>variable(s) may do (shared-memory concurrency). For more complex control-flow cases, we offer the <a href="http://brucou.github.io/projects/component-combinators/efsm/"><code>FSM</code> combinator</a>, which implements a state machine, which add control flow capabilities to the shared memory concurrency model. While state machines allow to manage a higher level of complexity, they remains a rather low-level tool for concurrency control.<br>  Declarative concurrency is a simpler concurrency model (for instance through a specific DSL for<br>  concurrency (like <a href="http://reo.project.cwi.nl/reo/" target="_blank" rel="noopener">Reo</a> or <a href="https://mozart.github.io/mozart-v1/doc-1.4.0/tutorial/node8.html#chapter.concurrency" target="_blank" rel="noopener">Oz</a>) to express the concurrency requirements separately for the sequential computations. The latter option would however require a different architecture than the one we are presently discussing, and as<br>  such, we do not pursue this option here.</p><p>Also worth mentioning, <code>cyclejs</code> matches each action handler (driver) to a moniker (sink name).<br>This brings the following concurrency issue : if two, somehow dependent actions, have to be executed, they must be collected into a single new action. Imagine a user action which leads to some remote data updates, <strong>and then</strong> a<br>change of route. Passing both actions in the same tick means the change of route might happen even<br> if the data update has failed, or before the data update is successfully performed while it should happen only after. In short, sinks best represent <strong>independent</strong> actions. If actions are linked, they must either be<br> passed one by one, with the adecuate control flow implemented, or coordinated through a new<br> action capturing that dependency in its execution.</p><h2 id="Error-handling"><a href="#Error-handling" class="headerlink" title="Error handling"></a>Error handling</h2><p>Leaving aside unexpected errors, or exceptions, there are expected errors which are part of the<br>specification of a reactive system. For instance, a user tries to book a trip but the<br>reservation system is not responding, or the seat that was available while browser is no longer<br>available when booking. Those errors generally prevent the system to move from one state (<code>booking</code>)<br> to another (<code>booked</code>). They can hence use simple state variables in the simplest cases, or a<br> full-fledge state machine (<code>FSM</code> combinator) for complex control flows. The <a href="https://github.com/brucou/component-combinators/tree/master/examples/volunteerApplication" target="_blank" rel="noopener">example</a> for <code>FSM</code> illustrates the <a href="/img/graphs/sparks%20application%20process%20with%20comeback%20fsm.png">intricated control flow</a> behind a multi-step<br> application process, where at every step input validation may fail.</p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>In summary, reactive systems can be specified by means of a reactive function associating inputs to actions. That reactive function can be obtained by composition of reactive functions from smaller reactive systems.</p><p>A good decomposition or factoring is one :</p><ul><li>which ensures for each subsystem a reduction in complexity<br>(simpler specifications, smaller size of the reactive system, few interactions with other subsystems i.e. intercomponent dependency)</li><li>which can be reassembled in a way that is easy to reason about and trace</li><li>can be parameterized without modification (open-closed principle), so futures changes in the overall reactive system have a higher chance to result mainly in changes in parameterization of subsystems</li><li>highly cohesive, loosely coupled to ensure adaptability<sup><a href="#fn_adaptability" id="reffn_adaptability">adaptability</a></sup></li></ul><blockquote id="fn_adaptability"><sup>adaptability</sup>. 80% of software engineering deals with maintaining or releasing new versions. The cost of redesigning each of such adoptable components (or replacing by a better component) must be minimized.<a href="#reffn_adaptability" title="Jump back to footnote [adaptability] in the text."> &#8617;</a></blockquote><p>In our reactive system, <code>cyclejs</code> context: for component construction and interfacing, functions are used, exposing a fixed interface, differentiating parameterization concern and input interface concern in their inputs; a port metaphor is used for interfacing components; combinators are used for parallel and sequential composition; component lifecycle is handled by the framework by means of <em>start</em> (here <code>run</code>) and <em>stop</em><br>functionalities, and rxjs streams’ lazy instantiation and automatic completion propagation.</p><p>A range of generic combinators have been defined, which allows to handle a series of concerns,<br>including sequential composition, state injection, control flow, routing, list management, change<br>propagation, etc. They are tools which can be used to for concurrency control (however imperfect<br>they be), state management, and error management for the application at hand.</p><h1 id="Possible-improvements"><a href="#Possible-improvements" class="headerlink" title="Possible improvements"></a>Possible improvements</h1><p>The list of possible improvements is large (cf. the <a href="https://github.com/brucou/component-combinators#roadmaps" target="_blank" rel="noopener">roadmap</a> for a partial list). At the conceptual level, for instance, it will be interesting to come up with a better concurrency model (cf. <code>Redux-saga</code>) fitting within the limits of the architecture. At a more practical level, error<br>management could be improved to facilitate more user-friendly options, for instance <code>React</code>-inspired <a href="https://reactjs.org/docs/error-boundaries.html" target="_blank" rel="noopener">fallback UI</a>).</p><h1 id="Bibliography"><a href="#Bibliography" class="headerlink" title="Bibliography"></a>Bibliography</h1><ul><li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.450.9230&amp;rep=rep1&amp;type=pdf" target="_blank" rel="noopener">Software Component Models - Component Life Cycle</a></li><li><a href="http://www.win.tue.nl/~johanl/educ/2II45/ADS.09.CBSE.pdf" target="_blank" rel="noopener">Component Based Systems - 2011</a></li><li><a href="http://www.myreadingroom.co.in/notes-and-studymaterial/65-dbms/532-concurrency-problems.html" target="_blank" rel="noopener">Concurrency Control Problems</a></li><li><a href="http://courses.cs.vt.edu/cs5204/fall10-kafura-BB/Presentations/Concurrency-Issues.pdf" target="_blank" rel="noopener">Concurrency Issues Motivation, Problems, Directions</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Background&quot;&gt;&lt;a href=&quot;#Background&quot; class=&quot;headerlink&quot; title=&quot;Background&quot;&gt;&lt;/a&gt;Background&lt;/h1&gt;&lt;p&gt;A component framework or platform prov
      
    
    </summary>
    
      <category term="programming" scheme="https://brucou.github.io/categories/programming/"/>
    
    
      <category term="functional programming" scheme="https://brucou.github.io/tags/functional-programming/"/>
    
      <category term="reactive programming" scheme="https://brucou.github.io/tags/reactive-programming/"/>
    
      <category term="components" scheme="https://brucou.github.io/tags/components/"/>
    
  </entry>
  
  <entry>
    <title>Componentization against complexity</title>
    <link href="https://brucou.github.io/2017/07/01/Componentization%20against%20complexity/"/>
    <id>https://brucou.github.io/2017/07/01/Componentization against complexity/</id>
    <published>2017-06-30T22:00:00.000Z</published>
    <updated>2019-05-26T03:40:06.374Z</updated>
    
    <content type="html"><![CDATA[<h1 id="The-power-of-abstraction"><a href="#The-power-of-abstraction" class="headerlink" title="The power of abstraction"></a>The power of abstraction</h1><p>We have <a href="/posts/user-interfaces-as-reactive-systems/">previously</a> seen that a reactive system can be described by equations involving a reactive function <code>f</code> such that <code>actions = f(state, events)</code>. In theory, the function <code>f</code> is as complex as the specification of the reactive system to implement. In practice, it is often much more so, as dictated by the particular implementation choices made.</p><p>Complexity resists to a uniformally useful definition. However, it is generally accepted that there is a component of complexity which cannot be reduced by any particular technique. <em>How many systems do we have? In what convoluted manner are they connected? What the requirement for operating these systems? How many parameters or subtasks are necessary to specify a task?</em>. That complexity increases every year, as the trend is into interconnecting more and more systems to satisfy ever astringent user requirements to do more things in less time. To reuse a commonly used term, we will call this the essential complexity of the system under specification.</p><p>Oddly enough, at the same time, on a subjective level, things that were complex last year are less complex now. That subjective but very real component of complexity relates the number of things that cause problems to our ability to deal with them. Our ability to deal with them goes up as we develop better languages, tools, interfaces, architecture, infrastructure, etc. and are able to do more with less. We would define this component of complexity as accidental complexity, and as being the complexity that an <strong>implementation approach</strong> adds to the essential complexity corresponding to the <strong>specification</strong> of a system.</p><p>As a side note, a user interface itself is precisely an attempt at shielding the user from the complexity of underlying systems so he can focus on the domain at hand and the tasks it encompasses. In other words, the user interface <strong>abstracts</strong> out the underlying system layer. As a matter of fact, most advances against accidental complexity (in <strong>any</strong> field) are made by better and/or more powerful abstractions.</p><p>As a matter of fact, we can list a short range of abstractions taking aim at specific sources of<br>complexity, at the system implementation level :</p><ul><li>domain : domain modeling</li><li>programming language : domain-specific language</li><li>persistence : databases</li><li>asynchrony : promises, tasks, streams (!!)</li><li>memory : garbage collector, constructors/destructors</li><li>testing : model-based testing</li><li>design : componentization</li><li>programming paradigm : declarative programming (including functional programming, dataflow programming, logic programming)  </li></ul><p>In the current state of my knowledge, I believe that the most effective levers in mastering complexity are domain modelling, domain-specific languages, and components, glued together by means of declarative programming.</p><p>We will detail in what follows what makes componentization an abstraction, the benefits to be expected, but also the costs and barriers associated, concluding that componentization is a strategic decision to be pondered over.</p><h1 id="Componentization-as-an-abstraction"><a href="#Componentization-as-an-abstraction" class="headerlink" title="Componentization as an abstraction"></a>Componentization as an abstraction</h1><p>The major goal in software construction is to build software that is robust (i.e. performs correctly and does not crash even in unforeseen cases), flexible (i.e. can be used in many seemingly different applications), extensible (i.e. can be extended with minimal if not no modification of existing code), easy to maintain (i.e. to modify to improve performance or fix “bugs”). The main tool of the trade of software developers can be summarized in one word: abstraction.</p><p>The abstraction process involves several steps:</p><ul><li>Eliminate all unnecessary details and get to the essential elements of the problem and express them clearly and concisely as invariants</li><li>Encapsulate those which vary and express them as variants.  The variants of abstractly equivalent behaviors are grouped into an appropriate taxonomy of abstract classes and subclasses</li><li>Define the dynamics of the system in terms of the  interplay between the invariants and the variants.  Sometimes the invariants/variants interplays can be straightforward, but more than often they can be subtle like the case when an invariant can be expressed in terms of many variants</li></ul><p>The effort spent in identifying and delineating the invariants from the variants usually leads to the construction of what is called a component framework system where the invariants form the framework and the variants constitute the components.</p><p><img src="https://www.clear.rice.edu/comp310/JavaResources/frameworks/frameworks.png" alt="Component framework"></p><p>Hence, in essence, component frameworks break the system down into variant “components” that represent abstract processing that the system supports. These components are generally thought of as “pluggable” in the sense that the system can be configured with a set of components to accomplish a particular task or set of tasks.   In many systems, the components can be dynamically swapped in and out.   The framework, on the other hand, is the invariant “superstructure” that manages the components, providing services to each component that, when combined with the services/behaviors supplied by that component, create the net behavior defined by that component in that framework.    The framework has the effect of decoupling or isolating the components <strong>from each other</strong> while coupling them to the framework.</p><h1 id="Benefits"><a href="#Benefits" class="headerlink" title="Benefits"></a>Benefits</h1><p>As previously mentioned, the benefits are :</p><ul><li>productivity, coming from a component framework design targeted at reuse, and composability</li><li>readability<ul><li>when a given component addresses a specific concern, and do so exclusively (i.e. achieving separation of concerns), the reactive system is easier to reason about</li></ul></li><li>maintainability<ul><li>components can be replaced easily, by a better or equivalent version, as long as its<br>interface its kept (<a href="https://tuhrig.de/programming-to-an-interface/" target="_blank" rel="noopener">program to an interface, not to an implementation</a>)  </li></ul></li><li>reliability<ul><li>in the measure that components and the component framework are properly tested and reliable, the surface area on which bugs can attach themselves is considerably lower</li></ul></li></ul><h1 id="Barriers-to-reuse"><a href="#Barriers-to-reuse" class="headerlink" title="Barriers to reuse"></a>Barriers to reuse</h1><p>Despite all the potential of componentization, significant barriers to component reuse have been observed :</p><ul><li>The business model is unclear</li><li>It costs a client too much to understand and use a component</li><li>Components have conflicting world views</li></ul><p>Componentization is hence a strategic decision which will depend on a company’s strategic context.</p><h2 id="Unclear-business-model"><a href="#Unclear-business-model" class="headerlink" title="Unclear business model"></a>Unclear business model</h2><p>Design is expensive, and reusable designs are very expensive. It costs between ½ and 2 times as much to build a module with a clean interface that is well-designed for your system as to just write some code, depending on how lucky you are. But a reusable component costs 3 to 5 times as much as a good module.</p><p>The extra money pays for:</p><ul><li>generality<ul><li>A reusable module must meet the needs of a fairly wide range of ‘foreign’ clients, not just of people working on the same project. Figuring out what those needs are is hard, and designing an implementation that can meet them efficiently enough is often hard as well.</li></ul></li><li>simplicity<ul><li>Foreign clients must be able to understand the interface to a module fairly easily, or it’s no use to them.</li></ul></li><li>customization<ul><li>To make the module general enough, it probably must be customizable, either with some well-chosen parameters or with some kind of programmability</li></ul></li><li>testing<ul><li>Foreign clients have higher expectations for the quality of a module, and they use it in more different ways. The generality and customization must be tested as well</li></ul></li><li>documentation<ul><li>Foreign clients need more documentation, since they can’t come over to your office</li></ul></li><li>stability<ul><li>Foreign clients are not tied to the release cycle of a system. Ideally for them, a module’s behaviour should remain unchanged (or upward compatible) for years, probably for the lifetime of their system</li></ul></li></ul><p>Designing for all those aspects is an investment that must be recouped in the future. Apart from very large companies, such as google or facebook, and some popular open-source projects, or large software development firms, the business case for such investment is not clear.</p><h2 id="Cost-to-understand"><a href="#Cost-to-understand" class="headerlink" title="Cost to understand"></a>Cost to understand</h2><p>To use a component, the client must understand its behaviour. This is not just the functional specification, but also the resource consumption, the exceptions it raises, its customization facilities, its bugs, and what workarounds to use when it doesn’t behave as expected or desired.</p><p>Furthermore, because the written spec is often quite inadequate, there is uncertainty about the cost to discover the things that are not in the spec, and about the cost to deal with the surprises that turn up. If the module has been around for a while and has many satisfied users, these risks are of course smaller, but it is difficult to reach this happy<br>state.</p><h2 id="Conflicting-world-views"><a href="#Conflicting-world-views" class="headerlink" title="Conflicting world views"></a>Conflicting world views</h2><p>Components are tied to a component framework, which defines its interface and lifecycle, by thus limiting the scope of their reuse out of that framework. Adapters and bridges can be built to palliate that situation. However that is not always possible or practical.</p><p>As a matter of fact, Angular2 components can hardly be reused out of Angular2, React components<br>can be adapted to React-like frameworks but it takes some efforts, etc. Web components, which are supposed to be a common standard, allowing reuse in all browsers, have been arriving for many years, and are still a work in progress, illustrating the difficulty of designing simultaneously for many targets.</p><h2 id="Componentization-is-a-strategic-decision"><a href="#Componentization-is-a-strategic-decision" class="headerlink" title="Componentization is a strategic decision"></a>Componentization is a strategic decision</h2><p>The option of componentization to implement a reactive system, must, like any architectural decision, be weighted in the context of the specific implementing company/project/team. A start-up who will anyways trash its minimum viable product the next year after receiving funding  might prefer to avoid going through the trouble, while companies which are constantly developing software might want to invest in carefully designed components.</p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>The eternal quest for productivity in software development is a quest for managing complexity, in<br> particular the accidental complexity that we create ourselves by the particular design, set of<br> tools, implementation, etc. thrown at the problem at hand. Four abstractions, in my (unscientific)<br> opinion, give the best result for complexity reduction : declarative programming, domain modeling,<br> domain specific languages, and componentization. </p><p>Componentization, however, is a double-edge sword : increasing productivity through reuse in the long-term, but costly in the short-term. As such, the decision of embarking on a componentization effort, and calibrating the scope of such, is a strategic decision which must be taken on a case-by-case basis.</p><h1 id="Bibliography"><a href="#Bibliography" class="headerlink" title="Bibliography"></a>Bibliography</h1><ul><li>F. P. Brooks Jr. No silver bullet - essence and accidents of software engineering. IEEE<br>Computer, 20(4):10–19, 1987</li><li>Fundamental Approaches to Software Engineering: 9th International Conference, FASE 2006, Held<br>as Part of the Joint European Conferences on Theory and Practice of Software, ETAPS 2006, Vienna, Austria, March 27-28, 2006, Proceedings</li><li><a href="https://www.dre.vanderbilt.edu/~schmidt/reuse-lessons.html" target="_blank" rel="noopener">Why Software Reuse has Failed and How to Make It Work for You</a></li><li><a href="https://www.sei.cmu.edu/podcasts/podcast_episode.cfm?episodeid=443886" target="_blank" rel="noopener">Reducing Complexity in Software &amp; Systems</a></li><li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.450.9230&amp;rep=rep1&amp;type=pdf" target="_blank" rel="noopener">Software Component Models - Component Life Cycle</a></li><li><a href="http://www.win.tue.nl/~johanl/educ/2II45/ADS.09.CBSE.pdf" target="_blank" rel="noopener">Component Based Systems - 2011</a></li><li><a href="https://www.clear.rice.edu/comp310/JavaResources/frameworks" target="_blank" rel="noopener">Component-Framework Systems</a></li><li><a href="https://link.springer.com/content/pdf/10.1007/3-540-45923-5_3.pdf" target="_blank" rel="noopener">A Generic Component Framework for System Modeling</a></li><li><a href="https://www.microsoft.com/en-us/research/publication/software-components-only-the-giants-survive/" target="_blank" rel="noopener">Software Components: Only The Giants Survive</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;The-power-of-abstraction&quot;&gt;&lt;a href=&quot;#The-power-of-abstraction&quot; class=&quot;headerlink&quot; title=&quot;The power of abstraction&quot;&gt;&lt;/a&gt;The power of a
      
    
    </summary>
    
      <category term="programming" scheme="https://brucou.github.io/categories/programming/"/>
    
    
      <category term="functional programming" scheme="https://brucou.github.io/tags/functional-programming/"/>
    
      <category term="reactive programming" scheme="https://brucou.github.io/tags/reactive-programming/"/>
    
      <category term="components" scheme="https://brucou.github.io/tags/components/"/>
    
  </entry>
  
  <entry>
    <title>User interfaces as reactive systems</title>
    <link href="https://brucou.github.io/2017/06/11/User%20interfaces%20as%20reactive%20systems/"/>
    <id>https://brucou.github.io/2017/06/11/User interfaces as reactive systems/</id>
    <published>2017-06-10T22:00:00.000Z</published>
    <updated>2019-06-11T02:22:18.123Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>As the name suggests, user interfaces allow a user to <strong>interface</strong> with other systems, with the idea that this interface will present some sought-for advantages vs. direct interaction with the mentioned systems.<br>For instance, when the interaction between systems becomes too complex (too many commands or sequences of commands, too many parameters, outputs difficult to exploit in their raw form, etc.), a user interface can help to reduce the cognitive load and the risk of errors on the user side. As a trivial example, while it is possible for a travel agent to interact directly with the reservation system, doing so through a well-designed user interface allows to have agents with little knowledge of the intricacies of the underlying systems. They can focus instead on mastery of their specific <strong>domain</strong> (travel<br>packages, customer segments, etc.) and the <strong>user stories</strong> which the user interface facilitates<br>(book a flight, cancel a hotel, etc.).</p><p>The user expresses an intent through some input means (key presses, vocal entry, etc.) with a view to realize pre-defined actions on the interfaced systems. Hence <strong>user interfaces are reactive systems</strong> almost by nature.</p><p>They are additionally <strong>concurrent systems</strong>, as the user can continue to send orders through the<br>user interface without waiting for the currently processed order to be completed. As such, user interface programming has the added complication of handling concurrency, both at a system and user interface level.</p><p>Any specification and implementation techniques for user interfaces must then specify a <strong>correspondence between user inputs and system actions</strong>, and the concurrent behaviour of the system. We will review thereafter specification and implementation techniques.</p><h1 id="Specification-and-implementation-techniques"><a href="#Specification-and-implementation-techniques" class="headerlink" title="Specification and implementation techniques"></a>Specification and implementation techniques</h1><p>In all what follows, it will be implicit that <code>event</code> and <code>action</code> are representations of the corresponding entities, i.e. not the actual events or actions, whatever that be, but symbols for those.</p><p>Functional and technical specifications for reactive systems must allow to extract :</p><ol><li>an interface by which the reactive system receives its events</li><li>a relation between events and actions such that $event \sim action$, where<ul><li>$\sim$ is called here the reactive relation</li><li>event is an event received through the user interface and triggering an action. Events can be<ul><li>user-initiated</li><li>system-initiated i.e. generated by the environment or external world</li></ul></li></ul></li><li>an interface with the systems through which actions intended by the user must be performed</li></ol><p>Because most reactive systems are stateful, the relation $\sim$ is not in general a <strong>deterministic</strong> (the same output associated for the same input, as opposed to probabilistic functions) <strong>function</strong> (which can only associate <strong>ONE</strong> output to an input).</p><p>Many frameworks for implementing user interfaces (<code>Angular2</code>, <code>Ember</code>,<br><code>Ractive</code>, <code>React</code>, etc.) make use of callback <strong>procedures</strong><sup><a href="#fn_defProcedure" id="reffn_defProcedure">defProcedure</a></sup>, or event handlers, which, when triggered by an event, directly <strong>perform</strong> the corresponding action. A few important issues stem from that choice : </p><ul><li>having the procedure directly handling in the same bundle different concerns such as input validation, performing triggered actions, error management, updating local state, makes it harder to trace, debug and reason about the program execution. The concurrent nature of user interfaces magnifies this issue. </li><li>procedures also do not compose as easily as pure functions, which limits the use of componentization techniques to reduce complexity and increase reuse. As a matter of fact, <code>React</code>‘s componentization model is limited to<br>addressing the view concern.</li><li>while generally optimized, efficient, and thorough, the low-level description such frameworks<br>offer is very far from the specification of the systems, making implementation error-prone and certification activities very difficult.</li></ul><p>However, when the reactive relation can be made into a deterministic function, by separating events and actions from their representation, and making local state explicit, miscellaneous implementation methods borrowing at various degrees from functional programming techniques, have some nice characteristics. We will focus in what follows on such implementation techniques.</p><p>To that purpose, we identify three models, which will be detailed thereafter :</p><ul><li>a reactive function gives for each event both the local state update, and the action to perform (<code>Elm</code> model)</li><li>a reactive function expressed as the transition function for an automata (state machine model)</li><li>a reactive function specified as a set of concurrent equations (the formal model)</li></ul><p>In any case, a reactive system run leads to traces which are the sequence of <code>(events, actions)</code><br>which have occurred during the period of the run. To a correct behaviour of a reactive system<br>corresponds a set of admissible traces. Conversely, testing a reactive system consists in<br>invalidating actual traces vs. the set of admissible traces. We will finish with addressing the<br>visualization of such traces.</p><blockquote id="fn_defProcedure"><sup>defProcedure</sup>. In the present context, a procedure is a routine, i.e. a sequence of statements, written against a runtime system, which executes them. Such procedures may or may not take arguments, may or may not return values, and may or may not perform side-effects.<a href="#reffn_defProcedure" title="Jump back to footnote [defProcedure] in the text."> &#8617;</a></blockquote><h2 id="Reactive-system-as-a-joint-specification-of-local-state-updates-and-actions"><a href="#Reactive-system-as-a-joint-specification-of-local-state-updates-and-actions" class="headerlink" title="Reactive system as a joint specification of local state updates and actions"></a>Reactive system as a joint specification of local state updates and actions</h2><p>Most of the time, it is possible to formalize a state for the reactive system such that : $(action, new\ state) = f(state, event)$ where :</p><ul><li>$f$ is a pure function</li><li>$state$ subsumes all the variability resulting from the environment and the reactive system’s specifications, so that $f$ is pure</li></ul><p>$f$ will be termed here as the <strong>reactive function</strong>. If we index time chronologically by a natural integer, so that the index $n$ corresponds to the $n^{th}$ event occurring, we have :</p><ul><li>$(action_n,\ state_{n+1}) = f(state_n,\ event_n) $ where :<ul><li>$n$ is the $n^{th}$ event processed by the reactive system</li><li>$state_n$ is the state of the reactive system <strong>when the $n$th event is processed</strong></li><li>we hence have an implicit temporal relation here between the event occurrence and the state used to compute the reaction of the system.</li></ul></li></ul><p>Those observations give rise to implementation techniques relying on a reactive function $f$ which <strong>explicitly</strong> computes and exposes for each event the new state of the reactive system, and the action to execute. Notable examples are :</p><ul><li><strong>Elm</strong> : The <code>update :: Msg -&gt; Model -&gt; (Model, Cmd Msg)</code> function corresponds closely to the reactive function $f$, <code>Msg</code> to <code>events</code>, <code>Model</code> to <code>states</code>, <code>Cmd Msg</code> to <code>actions</code>.</li><li><strong>Purescript/pux</strong> : <code>foldp :: ∀ fx. Event -&gt; State -&gt; EffModel State Event fx</code> function is the equivalent formulation within <a href="http://purescript-pux.org/docs/architecture/" target="_blank" rel="noopener">purescript/pux</a> framework</li></ul><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>Here is for example a run for the user story <code>User can book a trip</code>, for a reservation system :</p><div class="table-container"><table><thead><tr><th><code>n</code></th><th>Event</th><th>State (update)</th><th>Action</th></tr></thead><tbody><tr><td><code>0</code></td><td>Init</td><td>is_round_trip : false today_date = ‘13.12.2017’</td><td>Fetch recent searches, origin list, destination list</td></tr><tr><td></td><td></td><td></td><td>Display initial screen</td></tr><tr><td><code>1</code></td><td>Click on <code>Return ticket</code></td><td>is_round_trip : true</td><td>Update screen with <code>Return Departure</code> enabled</td></tr><tr><td><code>2</code></td><td>Click on <code>From</code> dropdown</td><td></td><td>Update screen to display <code>Stations</code> dropdown</td></tr><tr><td><code>3</code></td><td>Select <code>Vienna</code></td><td></td><td>Update screen to display chosen trip’s origin</td></tr><tr><td><code>4</code></td><td>Click on <code>To</code> input field</td><td></td><td></td></tr><tr><td><code>5</code></td><td>Type <code>p</code></td><td></td><td></td></tr><tr><td><code>6</code></td><td>Type <code>r</code></td><td></td><td></td></tr><tr><td><code>7</code></td><td>Type <code>a</code></td><td></td><td>Update screen with display of filtered origin list</td></tr><tr><td><code>8</code></td><td>Select Prague</td><td></td><td>Update screen to display chosen trip’s destination</td></tr><tr><td><code>9</code></td><td>Click on <code>Return Departure</code> input field</td><td></td><td>Update screen with calendar initialized with <code>today_date</code></td></tr><tr><td><code>10</code></td><td>Select <code>14.12.2017</code> as departure date</td><td></td><td>Update screen with chosen departure date</td></tr><tr><td><code>11</code></td><td>Click on <code>Search</code> button</td><td></td><td>Search API call to reservation database</td></tr><tr><td><code>12</code></td><td>API call completed successfully</td><td></td><td>Update screen with search results</td></tr></tbody></table></div><h2 id="Reactive-systems-as-automata"><a href="#Reactive-systems-as-automata" class="headerlink" title="Reactive systems as automata"></a>Reactive systems as automata</h2><p>By using streams to represent sequences over time, and using the functor associated to streams, the equation is rewrote as $(actions, next(states,\ events)) = f(states,\ events)$ where :</p><ul><li>$f$ is a pure function, taking a stream of events to a stream of actions</li><li>$next$ is derived from the reactive system’s specification<ul><li>i.e. specifying how the state of the reactive system changes in response to an event</li></ul></li><li>$states$ is a sequence where each value is the corresponding state of the reactive system at the time when an event is triggered, and subject to the equation :<ul><li>$states_0$ is the initial state of the system<ul><li>$next(states,\ events)$ is such that :<ul><li>$states_n = next(states_{n-1},\ events_{n-1})$ (1)</li></ul></li></ul></li></ul></li></ul><p>The $states$ stream hence has a recursive definition. Lazily-evaluated languages will allow for expressing $states$ quite naturally as a fixed point for $x \rightarrow next(x, events)$, while imperative languages may directly use<br>equation (1). We will refer to the <code>next</code> function as the <strong>state transition function</strong>.</p><p>Assuming the state transition function has been determined, the reactive system behaviour is<br>then entirely described by the following equations, which are those corresponding to a class of automata called state transducer<sup><a href="#fn_transducer" id="reffn_transducer">transducer</a></sup> :</p><blockquote id="fn_transducer"><sup>transducer</sup>. Finite-State Machines, <a href="http://www.cse.chalmers.se/~coquand/AUTOMATA/book.pdf" target="_blank" rel="noopener">http://www.cse.chalmers.se/~coquand/AUTOMATA/book.pdf</a>, cf. p.479<a href="#reffn_transducer" title="Jump back to footnote [transducer] in the text."> &#8617;</a></blockquote><script type="math/tex; mode=display">\begin{cases}states &=& next(states, events) \\\\\actions &=& f(states, events)\end{cases}</script><p>State transducers are state machines, which have an internal state, and on receiving an input, may produce an output and update their internal state. This opens the path to implementing reactive systems with state machines. This further opens the door to a well-studied set of techniques used in that area : tracing, visualization, automatic code generation, model-based testing, formal reasoning.</p><p>Knowing that state transducers are translators between input symbols and output symbols, it seems logical that they can be used for specifying and implementing reactive systems. As a matter of fact, a reactive system translates the actions of the user on the user interface to actions on the interfaced system.</p><p>A major reference for specification and implementation techniques based on the state machine formalism can be found in <em>Constructing the User Interface With Statecharts</em> by Ian Horrocks<sup><a href="#fn_Horrocks" id="reffn_Horrocks">Horrocks</a></sup>. Alternatively, an introduction to the technique can be found in this <a href="https://medium.com/@asolove/pure-ui-control-ac8d1be97a8d" target="_blank" rel="noopener">medium article</a>.</p><blockquote id="fn_Harel"><sup>Harel</sup>. Programming reactive systems with state charts, David Harel<a href="#reffn_Harel" title="Jump back to footnote [Harel] in the text."> &#8617;</a></blockquote><blockquote id="fn_Horrocks"><sup>Horrocks</sup>. <a href="https://www.amazon.com/Constructing-User-Interface-Statecharts-Horrocks/dp/0201342782" target="_blank" rel="noopener">Constructing the User Interface With State charts, Ian Horrocks</a> <a href="#reffn_Horrocks" title="Jump back to footnote [Horrocks] in the text."> &#8617;</a></blockquote><p>A typical application area for statecharts is rapid prototyping of embedded systems as they occur<br> in avionics and automobile industry. Among other things, their success comes from two facts :</p><ul><li>it is an easy to learn language for design specialists who have more often a degree in<br>electrical or electronic engineering than a solid background in computer science. Those engineers<br>have a considerably better intuition of the meaning of automata than of algebraic<br>specification techniques, for instance.<ul><li>statecharts are available as description technique in commercial products (StateMate, Rhapsody, Stateflow, Yakindu Statechart Tools, visualSTATE, and many more).</li></ul></li></ul><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h3><p>Here is, extracted from Ian Horrocks’ seminal book, an example of state charts specification for<br>a CD player. We reproduce here the state chart which synthesizes visually the state transition<br>function. Another document (not reproduced here) would specify the actual actions, and the<br>finer-grained modification to the state machine’s state to perform on transitioning, entering or<br>exiting control states:</p><p><img src="http://i.imgur.com/ygsOVi9.jpg" alt="CD player statechart specification"></p><h2 id="Reactive-systems-as-a-system-of-equations"><a href="#Reactive-systems-as-a-system-of-equations" class="headerlink" title="Reactive systems as a system of equations"></a>Reactive systems as a system of equations</h2><p>Assuming a monoid operation $\cup$ which allows to decompose actions into a sum of pieces, we can<br>write $actions = \cup_A actions_a$. Assuming that the same goes for events, and states :</p><script type="math/tex; mode=display">\begin{aligned}actions  & = \bigcup_A actions_a \\\\\         & = \bigcup_A f_a(states, events) \\\\\         & = \bigcup_A f_a(\bigcup\_{S_a} states_s, \bigcup\_{E_a} events_e)\end{aligned}</script><p>In FRP, $states<em>s$ are variables called behaviours, while $events_e$ and $actions_a$ are<br>events. We then rewrite our equation into a series of equations $actions_a = f_a(\cup\</em>{S<em>a} states_s, \cup\</em>{E_a} events_e)$, which computes actions of a given slice $a$ from the events $E_a$ and behaviours $S_a$ relevant to that<br>slice. As a matter of fact, it is often the case that a given action does not depend on the whole<br> set of events and behaviours but only a subset of such.</p><p>For instance, considering a reservation system with $events = \{search\_click, api\_call\_response\}$, and<br>$states =\{origin, destination, dates, cart\}$:  </p><script type="math/tex; mode=display">\begin{cases}api\\_call & = f(\\{origin, destination, dates\\}, search\\_click) \\\\\retry & = g(null, api\\_call\\_response) \\\\\show\\_payment\\_screen & = h(cart, api\\_call\\_response)\end{cases}</script><p>$api\_call$ does not depend on $cart$, nor does it depend on $api\_call\_response$.</p><p>Dataflow languages, such as Lucid Synchrone, use such an equational approach both for specification and implementation of reactive systems<sup><a href="#fn_synchronous" id="reffn_synchronous">synchronous</a></sup>. The approach used by Lucid Synchrone and the like is particularly interesting for user interfaces in safety-critical domain (avionics, automotive, medicine, nuclear plants…) with stringent certification requirements. By keeping the implementation close to the specification, restricting the target implementation language and defining formal semantics for it, it is possible to guarantee liveliness and safety properties of the implemented system.</p><blockquote id="fn_synchronous"><sup>synchronous</sup>. <a href="https://www.lri.fr/~sebag/Slides/Pouzet.pdf" target="_blank" rel="noopener">https://www.lri.fr/~sebag/Slides/Pouzet.pdf</a>, Functional Synchronous Programming of Reactive Systems ; <a href="https://www.di.ens.fr/~pouzet/bib/chap_lucid_synchrone_english_iste08.pdf" target="_blank" rel="noopener">https://www.di.ens.fr/~pouzet/bib/chap_lucid_synchrone_english_iste08.pdf</a>, Synchronous Functional Programming: The Lucid Synchrone Experiment<a href="#reffn_synchronous" title="Jump back to footnote [synchronous] in the text."> &#8617;</a></blockquote><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example"></a>Example</h3><p>We reproduce here the coffee machine example taken from <a href="https://www.di.ens.fr/~pouzet/lucid-synchrone/lucid-synchrone-3.0-manual.pdf" target="_blank" rel="noopener">lucid synchrone manual</a>. The description is the following. The machine may serve coffee or tea. A tea costs ten cents whereas a coffee costs five. The user may enter dimes or nickels. He can select a tea, a coffee or ask for his money back.</p><p>We see thereafter how the streams <code>drink</code> and <code>devolution</code> are equationally derived from streams<br><code>coin</code> and <code>button</code>, which are themselves derived from external systems (here the keyboard)<br><sup><a href="#fn_lucid" id="reffn_lucid">lucid</a></sup>. </p><blockquote id="fn_lucid"><sup>lucid</sup>. Note the use of recursivity to equationally define the operator <code>coffee</code> : use of <code>rec</code> and <code>last</code>. Also, the keyword <code>node</code> is used to indicate <em>combinatorial</em> streams (vs. sequential streams), which are streams whose current value depends on past values. <a href="#reffn_lucid" title="Jump back to footnote [lucid] in the text."> &#8617;</a></blockquote><pre><code class="hljs undefined">type coin = Dime | Nickeltype drinks = Coffee | Teatype buttons = BCoffee | BTea | BCancel(* producing events from the keyboard *)let node input key = (coin, button) wherematch key with    &quot;N&quot; -&gt; do emit coin = Nickel done  | &quot;D&quot; -&gt; do emit coin = Dime done  | &quot;C&quot; -&gt; do emit button = BCoffee done  | &quot;T&quot; -&gt; do emit button = BTea done  | &quot;A&quot; -&gt; do emit button = BCancel done  | _ -&gt; do done  end(* Now we define a function which outputs a drink and returns some money when necessary. *)let node coffee coin button = (drink, devolution) where  rec last v = 0  and present      coin(Nickel) -&gt;        do v = last v + 5 done      | coin(Dime) -&gt;        do v = last v + 10 done      | button(BCoffee) -&gt;        do (drink, v) = vend Coffee 10 (last v)        done      | button(BTea) -&gt;        do (drink, v) = vend Tea 5 (last v)        done      | button(BCancel) -&gt;        do v = 0        and emit devolution = last v        done  end(* auxiliary : emits a drink if the accumulated value [v] is greater than [cost] *)let node vend drink cost v = (o1, o2) where    match v &gt;= cost with      true -&gt;        do emit o1 = drink        and o2 = v - cost        done    | false -&gt;        do o2 = v done    end</code></pre><h3 id="An-imperative-language-approach"><a href="#An-imperative-language-approach" class="headerlink" title="An imperative language approach"></a>An imperative language approach</h3><p>A similar, though more relaxed approach, is taken by <code>cyclejs</code> which further collapses the $states$ stream into the $actions$ streams, by considering that state change is itself an action over the internal state of the system. To keep the equivalence to the original formulation, this approach however requires to clearly and consistently define the timing of the internal state update action vs. actions on the interfaced external systems : the internal state update must be executed before the next event is processed<sup><a href="#fn_instantStateUpdate" id="reffn_instantStateUpdate">instantStateUpdate</a></sup>. In the cycle framework, <code>App :: Sources -&gt; Sinks</code>, where <code>Sources</code> contains any necessary accessor/factory methods for the state of the system and events admitted by the system, and <code>Sinks</code> holds the actions triggered by the events.</p><p>Here is an example of cyclejs code, showing the split of the actions into two action streams,<br>each computed from its corresponding events and behaviours :</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">NavigationItem</span>(<span class="hljs-params">sources, settings</span>) </span>&#123;  <span class="hljs-keyword">const</span> &#123; url$ &#125; = sources;  <span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">project</span>: &#123; title, link &#125; &#125; = settings;  <span class="hljs-keyword">const</span> linkSanitized = link.replace(<span class="hljs-regexp">/\//i</span>, <span class="hljs-string">'_'</span>);  <span class="hljs-keyword">const</span> events = &#123;    <span class="hljs-comment">// NOTE : we avoid having to isolate by using the link which MUST be unique over the whole</span>    <span class="hljs-comment">// application (unicity of a route)</span>    click : sources.DOM.select(<span class="hljs-string">`.navigation-section__link.<span class="hljs-subst">$&#123;linkSanitized&#125;</span>`</span>).events(<span class="hljs-string">'click'</span>)  &#125;;  <span class="hljs-keyword">const</span> state$ = url$    .map(<span class="hljs-function"><span class="hljs-params">url</span> =&gt;</span> url.indexOf(link) &gt; <span class="hljs-number">-1</span>)    .shareReplay(<span class="hljs-number">1</span>);  <span class="hljs-keyword">const</span> actions = &#123;    <span class="hljs-attr">domUpdate</span> : state$.map(<span class="hljs-function"><span class="hljs-params">isLinkActive</span> =&gt;</span> &#123;      <span class="hljs-keyword">const</span> isLinkActiveClass = isLinkActive ? <span class="hljs-string">'.navigation-section__link--active'</span> : <span class="hljs-string">''</span>;      <span class="hljs-keyword">return</span> a(        <span class="hljs-string">`<span class="hljs-subst">$&#123;isLinkActiveClass&#125;</span>.navigation-item.navigation-section__link.<span class="hljs-subst">$&#123;linkSanitized&#125;</span>`</span>,        &#123; <span class="hljs-attr">attrs</span>: &#123; <span class="hljs-attr">href</span>: link &#125;, <span class="hljs-attr">slot</span>: <span class="hljs-string">'navigation-item'</span> &#125;,        title)    &#125;),    <span class="hljs-attr">router</span> : events.click      .do(preventDefault)      .map(always(<span class="hljs-string">'/'</span> + link + <span class="hljs-string">'/'</span>))  &#125;  <span class="hljs-keyword">return</span> &#123;    [DOM_SINK]: actions.domUpdate,    <span class="hljs-attr">router</span>: actions.router  &#125;&#125;</code></pre><blockquote id="fn_cycle"><sup>cycle</sup>. cycle however gives up on the purity of $f$ in exchange for a familiar interface for componentization - components are simply functions ; but keeps discriminating between action and action representation.<a href="#reffn_cycle" title="Jump back to footnote [cycle] in the text."> &#8617;</a></blockquote><blockquote id="fn_instantStateUpdate"><sup>instantStateUpdate</sup>. so that we maintain $states_n = next(states_{n-1}, events_{n-1})$. If the $n$th event would be processed before $state_n$ is set through the equation, the $next$ function could be computing an invalid state for the reactive system.<a href="#reffn_instantStateUpdate" title="Jump back to footnote [instantStateUpdate] in the text."> &#8617;</a></blockquote><h2 id="Visualization"><a href="#Visualization" class="headerlink" title="Visualization"></a>Visualization</h2><p>A run from the aforementioned <a href="#example">trip reservation interface example</a> may be represented<br>more succinctly on a timelined diagram :</p><pre><code class="hljs csv">events : iccsctttscscSstate  : ++-----------actions: fuuu---uuuuSu         uc : click events : select eventt : type eventS : search API call event/actionu : update screen eventf : fetch remote data+ : state update</code></pre><p>Implementations of reactive systems which allow to obtain the trace of a run as a sequence of <code>(event, action)</code> (or any equivalent format) also allow to reduce testing of such systems to checking<br> an actual trace vs. a set of expected traces.</p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>User interfaces are reactive systems and as such can be specified by means of its events/actions interface with the external systems of interest, and a pure reactive function mapping the actions of the user on the user interface to actions on the interfaced system.  </p><p>Implementation techniques leveraging functional programming techniques, can lead to an implementation closer to the specification, easier to reason about and maintain. In the best case, implementations may be automatically generated from the specifications and amenable to formal verification.</p><h1 id="Bibliography"><a href="#Bibliography" class="headerlink" title="Bibliography"></a>Bibliography</h1><ul><li><a href="https://www.di.ens.fr/~pouzet/bib/chap_lucid_synchrone_english_iste08.pdf" target="_blank" rel="noopener"><strong>Synchronous Functional Programming: The Lucid Synchrone Experiment</strong></a><br>Chapter 1.1 is an amazing introduction to the drivers behind the rise of synchronous languages vs. regular languages for critical software(avionics etc.) : the closeness between specification and implementation allows to formally guarantee properties.</li></ul><blockquote><p>Synchronous languages are based on the synchronous hypothesis. This hypothesis comes from the idea of separating the functional description of a system from the constraints of the architecture on which it will be executed.</p></blockquote><ul><li><a href="https://www.lri.fr/~sebag/Slides/Pouzet.pdf" target="_blank" rel="noopener"><strong>Functional Synchronous Programming of Reactive Systems</strong></a><br>Rationale behind functional synchronous programming for reactive systems, domains of application, state of the art.</li></ul><blockquote><p>Concurrency and determinism are absent but they are fundamental! Design specific languages with a limited expressive power, a formal semantics, well adapted to the culture of the field</p></blockquote><ul><li><a href="https://mitpress.mit.edu/books/concepts-techniques-and-models-computer-programming" target="_blank" rel="noopener"><strong>Concepts, Techniques, and Models of Computer Programming</strong></a><br>chapter 4, in particular section 4.3.4.</li><li><a href="https://www.tablesgenerator.com/markdown_tables" target="_blank" rel="noopener">markdown tables helper</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Background&quot;&gt;&lt;a href=&quot;#Background&quot; class=&quot;headerlink&quot; title=&quot;Background&quot;&gt;&lt;/a&gt;Background&lt;/h1&gt;&lt;p&gt;As the name suggests, user interfaces 
      
    
    </summary>
    
      <category term="programming" scheme="https://brucou.github.io/categories/programming/"/>
    
    
      <category term="functional programming" scheme="https://brucou.github.io/tags/functional-programming/"/>
    
      <category term="reactive programming" scheme="https://brucou.github.io/tags/reactive-programming/"/>
    
      <category term="user interface" scheme="https://brucou.github.io/tags/user-interface/"/>
    
  </entry>
  
</feed>
